/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var log = require('oae-logger').logger('oae-search');
var Telemetry = require('oae-telemetry').telemetry('search');
var client = require('./elasticsearch');

// specifies whether or not we should allow the index to be manually refreshed
var allowRefreshIndex = false;

var documentTransformers = {

    /**!
     * A default document transformer that simply returns the raw search result.
     * @see registerDocumentTransformer
     */
    '*': function(ctx, searchType, docs, callback) {
        callback(null, docs);
    }
};

/**
 * Perform a search of a given type.
 *
 * @param {Context}     ctx             The current context of the request
 * @param {String}      searchType      The type of search to perform (e.g., 'general')
 * @param {Object}      opts            A hash describing the search parameters
 * @param {Function}    callback        Invoked when the process completes
 * @param {Object}      callback.err    An error that occurred, if any
 * @param {Object}      callback.result The search result object
 */
module.exports.search = function(ctx, searchType, opts, callback) {
    try {
        require('./searches/' + searchType)(ctx, documentTransformers, opts, callback);
    } catch (err) {
        // we catch an exception here in case the searches module specified does not exist
        log().error({
            err: err,
            ctx: ctx,
            searchType: searchType,
            opts: opts
        }, 'Exception thrown executing search.');
        return callback(err);
    }
}

/**
 * Register a transformer with the search API that will transform search documents into a model that can be returned to the
 * UI for the user.
 *
 * @param   {String}    typeName                    The type of document this transformer acts upon
 * @param   {Function}  transformer                 The function that will transform an array of search documents into an array of view objects
 * @param   {Context}   transformer.ctx             The context of the currently authenticated user
 * @param   {String}    transformer.searchType      The type of search that was performed to retrieve the documents (e.g., 'general')
 * @param   {Object}    transformer.docs            The raw search documents, keyed by document _id, that were returned in the search
 * @param   {Function}  transformer.callback        The callback function the transformer should execute to indicate it has completed processing
 * @param   {Object}    transformer.callback.err    An error that occurred while transforming the docs, if any
 * @param   {Object}    transformer.callback.docs   The view model, keyed by document _id, that were translated from the hash of search
 *                                                  documents
 */
module.exports.registerDocumentTransformer = function(typeName, transformer) {
    if (documentTransformers[typeName]) {
        return new Error('Document transformer for type ' + typeName + ' already exists');
    }
    documentTransformers[typeName] = transformer;
}

/**
 * Refresh the search configuration with the given options.
 *
 * @param   {String}    index               The index to use
 * @param   {Object}    serverOpts          The server opts with which to configure the client
 * @param   {Boolean}   allowRefreshIndex   Whether or not the API should allow the index to be manually refreshed
 */
module.exports.refreshSearchConfiguration = function(indexName, serverOpts, _allowRefreshIndex) {
    allowRefreshIndex = _allowRefreshIndex;
    client.refreshSearchConfiguration(indexName, serverOpts);
}

/**
 * Create an index with the specified name and settings.
 *
 * @param {String}      indexName       The name of the index
 * @param {Object}      settings        The settings of the ElasticSearch index
 * @param {Function}    callback        Invoked when the proces completes
 * @param {Object}      callback.err    An error that occurred, if any
 */
var createIndex = module.exports.createIndex = function(indexName, settings, callback) {
    client.createIndex(indexName, settings, callback);
}

/**
 * Delete the index with the given name.
 *
 * @param {String}      indexName       The name of the index to delete
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var deleteIndex = module.exports.deleteIndex = function(indexName, callback) {
    client.deleteIndex(indexName, callback);
}

/**
 * Determine whether or not the specified index exists.
 *
 * @param {String}      indexName       The name of the index to test
 * @param {Function}    callback        Invoked when the proces completes
 * @param {Object}      callback.err    An error that occurred, if any
 * @param {Boolean}     callback.exists Whether or not the index exists
 */
var indexExists = module.exports.indexExists = function(indexName, callback) {
    client.indexExists(indexName, callback);
}

/**
 * Refresh the current index so that all its documents are available for querying.
 *
 * @param {Context}     ctx             The context of the current request
 * @param {Function}    callback        Invoked when the process completes
 * @param {Object}      callback.err    An error that occurred, if any
 */
var refresh = module.exports.refresh = function(ctx, callback) {
    if (allowRefreshIndex) {
        client.refresh(callback);
    } else {
        return callback(new Error('Refreshing is not allowed.'));
    }
}

/**
 * Create a type mapping that can be searched.
 *
 * @param   {String}    typeName            The name of the type. Should be unique across the application.
 * @param   {Object}    fieldProperties     The field schema properties for the type, as per ElasticSearch mapping spec.
 * @param   {Object}    opts                Options to send with the query
 * @param   {Function}  callback            Invoked when the process completes
 * @param   {Object}    callback.err        An error that occurred, if any
 */
var putMapping = module.exports.putMapping = function(typeName, fieldProperties, callback) {
    client.putMapping(typeName, fieldProperties, null, callback);
}

/**
 * Determine whether or not the mapping exists.
 * 
 * @param   {String}    typeName        The name of the type to map.
 * @param   {Function}  callback        Invoked when the process completes.
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var mappingExists = module.exports.mappingExists = function(typeName, callback) {
    client.mappingExists(typeName, callback);
}

/**
 * Index the given document in ElasticSearch.
 *
 * @param   {String}    typeName        The type of document to index
 * @param   {Object}    doc             The document to index
 * @param   {Function}  callback        Invoked whent he process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
module.exports.index = function(typeName, doc, callback) {
    client.index(typeName, doc, null, callback);
}

/**
 * Delete the document identified by the document id from the index.
 *
 * @param   {String}    typeName        The type of document to delete
 * @param   {Object}    id              The id of the document to delete
 * @param   {Function}  callback        Invoked whent he process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
module.exports.delete = function(typeName, id, callback) {
    client.delete(typeName, id, callback);
}

