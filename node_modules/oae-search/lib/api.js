/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var FollowingDAO = require('oae-following/lib/internal/dao');
var log = require('oae-logger').logger('oae-search');
var MQ = require('oae-util/lib/mq');
var Telemetry = require('oae-telemetry').telemetry('search');

var client = require('./internal/elasticsearch');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchResult = require('oae-search/lib/model').SearchResult;
var SearchUtil = require('oae-search/lib/util');

// Indicates whether or not the search indexing handler has been bound to the task queue
var boundIndexWorkers = false;

var reindexAllHandlers = {};
var searches = {};
var searchDocumentProducers = {};
var searchDocumentTransformers = {
    /*!
     * A default document transformer that simply returns the stored fields of the document, plus the id.
     * @see registerSearchDocumentTransformer
     */
    '*': function(ctx, docs, callback) {
        var result = _.map(docs, function(doc) {
            return _.extend({}, doc.fields, { 'id': doc['_id'] });
        });
        return callback(null, result);
    }
};

/**
 * Refresh the search configuration with the given options.
 *
 * @param  {String}    index                   The index to use
 * @param  {Object}    serverOpts              The server opts with which to configure the client
 * @param  {Boolean}   processIndexJobs        Whether or not this node should process indexing jobs sent through the task queue
 * @param  {Function}  callback                Invoked when configuration has been refreshed
 */
var refreshSearchConfiguration = module.exports.refreshSearchConfiguration = function(indexName, serverOpts, processIndexJobs, callback) {
    client.refreshSearchConfiguration(indexName, serverOpts);

    if (processIndexJobs && !boundIndexWorkers) {
        boundIndexWorkers = true;
        MQ.bind(SearchConstants.mq.TASK_INDEX_DOCUMENT, _handleIndexDocumentTask, null, function() {
            MQ.bind(SearchConstants.mq.TASK_DELETE_DOCUMENT, _handleDeleteDocumentTask, null, function() {
                MQ.bind(SearchConstants.mq.TASK_REINDEX_ALL, _handleReindexAllTask, null, callback);
            });
        });
    } else if (!processIndexJobs && boundIndexWorkers) {
        boundIndexWorkers = false;
        MQ.unbind(SearchConstants.mq.TASK_INDEX_DOCUMENT, function() {
            MQ.unbind(SearchConstants.mq.TASK_DELETE_DOCUMENT, function() {
                MQ.unbind(SearchConstants.mq.TASK_REINDEX_ALL, callback);
            });
        });
    } else {
        // If we get here, there was no state change in handling indexing, so we don't need to do anything.
        callback();
    }
};

/**
 * Create a type mapping that can be searched. The type mappings use the elastic search type mapping specification, as described
 * in the ElasticSearch documentation: http://www.elasticsearch.org/guide/reference/api/admin-indices-put-mapping.html
 *
 * @param  {String}    typeName            The name of the type. Should be unique across the application.
 * @param  {Object}    fieldProperties     The field schema properties for the type, as per ElasticSearch mapping spec.
 * @param  {Object}    [opts]              Advanced mapping options
 * @param  {String}    [opts._parent]      The parent document type, if applicable
 * @param  {Boolean}   [opts._source]      Whether or not the _source document should be enabled. Defaults to `true`.
 * @param  {Function}  callback            Invoked when the process completes
 * @param  {Object}    callback.err        An error that occurred, if any
 */
var putMapping = module.exports.putMapping = function(typeName, fieldProperties, opts, callback) {
    client.putMapping(typeName, fieldProperties, opts, callback);
};

/**
 * Register a transformer with the search API that will transform search documents into a model that can be returned to the
 * UI for the user. There can only be one transformer per resource type. The document transformers are given the search documents
 * after they have been retrieved from ElasticSearch. Once transformed, the final search results are sent back to the client.
 *
 * @param  {String}    typeName                    The type of document this transformer acts upon
 * @param  {Function}  transformer                 The function that will transform an array of search documents into an array of view objects
 * @param  {Context}   transformer.ctx             The context of the currently authenticated user
 * @param  {Object}    transformer.docs            The raw search documents, keyed by document 'id', that were returned in the search
 * @param  {Function}  transformer.callback        The callback function the transformer should execute to indicate it has completed processing
 * @param  {Object}    transformer.callback.err    An error that occurred while transforming the docs, if any
 * @param  {Object}    transformer.callback.docs   The view model, keyed by document _id, that were translated from the hash of search documents
 * @throws {Error}                                 An error that is thrown if there is already a transformer registered for the given type
 */
var registerSearchDocumentTransformer = module.exports.registerSearchDocumentTransformer = function(typeName, transformer) {
    if (searchDocumentTransformers[typeName]) {
        throw new Error('Document transformer for type ' + typeName + ' already exists.');
    }
    searchDocumentTransformers[typeName] = transformer;
};

/**
 * Register a producer with the search API that will produce search documents to be added to the search index. There can only be one
 * producer per resource type. When a new indexing task is submitted for a resource that is of `typeName` resource type, then this
 * producer will have an opportunity to produce documents to be indexed.
 *
 * By default each document will have its `_type` set to `SearchConstants.resourceMappingName`.
 * If you've added a mapping for a new type, you can specify it on a search document by
 * giving it the appropriate value for the `_type` key.
 *
 * You can also specify a `_parent` value which can point to any search document in the index.
 *
 * @param  {String}    typeName                The resource type that this indexer indexes
 * @param  {Function}  producer                A function that will produce documents to be indexed
 * @param  {Object[]}  producer.resourceData   An array of objects that represent the data that drives the producer. The format of the actual data object will generally be different for different resource types
 * @param  {Function}  producer.callback       The callback function that should be invoked when the indexer has produced the documents
 * @param  {Object}    producer.callback.err   An error that occurred while creating the documents, if any
 * @param  {Object[]}  producer.callback.docs  The documents to be indexed
 * @throws {Error}                             An error that is thrown if there is already a producer registered for the given type
 */
var registerSearchDocumentProducer = module.exports.registerSearchDocumentProducer = function(typeName, producer) {
    if (searchDocumentProducers[typeName]) {
        throw new Error('Document producer for type ' + typeName + ' already exists.');
    }
    searchDocumentProducers[typeName] = producer;
};

/**
 * Register a search with the Search API that will process search input and produce a query to run against elastic search. Once the query
 * is created by the search registered here, the search will be sent to ElasticSearch and and all results will be passed through the
 * document transformers. @see #registerSearchDocumentTransformer for more information.
 *
 * @param  {String}    typeName                            The name of the search. Once registered, this search can be invoked by using this `typeName` in the `search` method.
 * @param  {Function}  queryBuilder                        The search function that will be invoked when a search is performed. This function is responsible for generating a query as per the ElasticSearch Query DSL and returning it in the callback.
 * @param  {Context}   queryBuilder.ctx                    The context of the search being performed
 * @param  {Object}    queryBuilder.opts                   The search opts that are specific to the search
 * @param  {String[]}  [queryBuilder.opts.params]          An array of search parameters that are specific to the search (i.e., for ordered path parameters)
 * @param  {Function}  queryBuilder.callback               The callback function that should be invoked when the search has created the query
 * @param  {Object}    queryBuilder.callback.err           An error that occurred while creating the query. Pass an error parameter to indicate an error occurred, if it was successful, this parameter should be left `null`
 * @param  {Object}    queryBuilder.callback.queryData     The Query DSL object representing the query, as per the ElasticSearch documentation; If not specified, short-circuits the process to return 0 results.
 * @throws {Error}                                         An error that is thrown if there is already a search registered by the given name
 */
var registerSearch = module.exports.registerSearch = function(typeName, queryBuilder) {
    if (searches[typeName]) {
        throw new Error('Search type ' + typeName + ' already exists.');
    }
    searches[typeName] = queryBuilder;
};

/**
 * Register a handler for a reindex all operation. When a full re-index has been triggered, this handler will be invoked.
 *
 * @param  {String}     handlerId               The id of the handler invoked
 * @param  {Function}   handler                 The handler function that will be invoked when a full re-index has been triggered
 * @param  {Function}   handler.callback        The callback function that should be invoked when reindexing has been completed
 * @param  {Object}     handler.callback.err    An error that occurred during reindexing, if any
 */
var registerReindexAllHandler = module.exports.registerReindexAllHandler = function(handlerId, handler) {
    if (reindexAllHandlers[handlerId]) {
        throw new Error('Reindex-all handler with id ' + handlerId + ' already exists.');
    }
    reindexAllHandlers[handlerId] = handler;
};

/**
 * Perform a search of a given type.
 *
 * @param  {Context}        ctx                 The current context of the request
 * @param  {String}         searchType          The type of search to perform (e.g., 'general')
 * @param  {Object}         opts                A hash describing the search parameters
 * @param  {String[]}       [opts.pathParams]   An array of path parameters for the search. The requirements of the path parameters are specific to the type of search being performed.
 * @param  {String}         [opts.q]            A full-text search query to apply to search with
 * @param  {Number}         [opts.limit]        The maximum number of search documents to return
 * @param  {Number}         [opts.start]        The document index from which to start
 * @param  {String}         [opts.sort]         The direction to sort the results. One of 'asc' or 'desc'
 * @param  {Function}       callback            Invoked when the process completes
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Object}         callback.result     The search result object
 */
var search = module.exports.search = function(ctx, searchType, opts, callback) {
    var registeredSearch = searches[searchType];
    if (!registeredSearch) {
        return callback({'code': 400, 'msg': 'Search "' + searchType + '" is not a valid search type.'});
    }

    // Invoke the search plugin to get the query object
    registeredSearch(ctx, opts, function(err, queryData) {
        if (err) {
            return callback(err);
        } else if (!queryData) {
            return callback(null, new SearchResult(0, []));
        }

        // Query only the document fields in the index, and not the _source and others
        queryData.fields = '*';

        // Perform the search with the query data
        client.search(queryData, null, function(err, results) {
            if (err) {
                log().error({'err': err}, 'An unexpected error occurred performing a search');
                return callback({'code': 500, 'msg': 'An unexpected error occurred performing the search'});
            }

            // We pull the '_extra' field out and parse it into JSON
            var hits = results.hits.hits;
            for (var i = 0; i < hits.length; i++) {
                var hit = hits[i];
                if (hit.fields._extra) {
                    try {
                        hit.fields._extra = JSON.parse(hit.fields._extra);
                    } catch (parseErr) {
                        log().warn({'err': parseErr, 'hit': hit}, 'Failed to parse _extra field of search document into JSON. Ignoring.');
                    }
                }
            }

            SearchUtil.transformSearchResults(ctx, searchDocumentTransformers, results, function(err, results) {
                if (err) {
                    return callback(err);
                }

                // Scrub the _extra field from all results
                var docs = results.results;
                if (docs && docs.length > 0) {
                    for (var i = 0; i < docs.length; i++) {
                        delete docs[i]._extra;
                    }
                }

                return callback(null, results);
            });
        });
    });
};

/**
 * Sends `IndexTasks` to the task queue so they can be picked up the search indexers
 *
 * @param  {IndexTask[]}    tasks           A set of tasks that need to be processed
 * @param  {Function}       [callback]      Standard callback function
 */
var submitIndexTasks = module.exports.submitIndexTasks = function(tasks, callback) {
    callback = callback || function() {};

    MQ.submit(SearchConstants.mq.TASK_INDEX_DOCUMENT, {
        'tasks': tasks
    }, callback);
};

/**
 * Submits a task that will re-index all search documents in storage.
 *
 * @param  {Context}    ctx             The processing context in which the reindexAll task was executed
 * @param  {Function}   callback        Invoked when the task has been submitted. Note that actual reindexing will happen asynchronously despite this callback.
 * @param  {Object}     callback.err    An error that occurred while invoking the task, if any
 */
var reindexAll = module.exports.reindexAll = function(ctx, callback) {
    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Only global administrator can trigger a full reindex.'});
    }

    MQ.submit(SearchConstants.mq.TASK_REINDEX_ALL, null, callback);
};

/**
 * When bound to an MQ reindex-all task, this method will reindex all resource in the search engine.
 *
 * @param  {Object}     data            The task data
 * @param  {Function}   callback        Invoked when all re-indexing has completed
 * @param  {Object}     callback.err    An error that occurred during re-indexing, if any
 * @api private
 */
var _handleReindexAllTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling reindex-all task.');
        }
    };

    var numToProcess = _.keys(reindexAllHandlers).length;
    if (numToProcess === 0) {
        // No handlers for reindexing, nothing to do
        return callback();
    }

    // Invoke all handlers and return to the caller when they have all completed (or we get an error)
    var complete = false;
    _.each(reindexAllHandlers, function(handler, handlerId) {
        handler(function(err) {
            if (complete) {
                // Do nothing, we've already returned to the caller
                return;
            } else if (err) {
                complete = true;
                return callback(err);
            }

            numToProcess--;
            if (numToProcess === 0) {
                log().info({'handlers': _.keys(reindexAllHandlers)}, 'Finished re-indexing all items.');
                complete = true;
                return callback();
            }
        });
    });
};

/**
 * When bound to an MQ delete document task, this method will delete the resource from the search engine.
 *
 * @param  {Object}    data            The task data
 * @param  {String}    data.id         The _id of the document to delete
 * @param  {Function}  callback        Invoked when indexing has completed
 * @param  {Object}    callback.err    An error that occurred, if any
 * @api private
 */
var _handleDeleteDocumentTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling search document delete task.');
        }
    };

    // Delete the resource document
    var errs = [];
    client.del(SearchConstants.resourceMappingName, data.id, function(err) {
        if (err) {
            errs.push(err);
        }

        // Delete all the child documents of this resource
        client.deleteByQuery('', SearchUtil.filterTerm('_parent', data.id), function(err) {
            if (err) {
                errs.push(err);
            }

            return callback(errs[0]);
        });
    });
};

/**
 * When bound to am MQ index document task, this method will index the resource document(s) as described by the
 * task data.
 *
 * @param  {Object}    data                The task data
 * @param  {String}    data.resourceType   The type of the resource being indexed
 * @param  {Object[]}  data.resources      An array of resources that are to be indexed. This should be in the format depended on in the resource type's custom document producer
 * @param  {Function}  callback            Invoked when indexing has completed
 * @param  {Object}    callback.err        An error that occurred, if any
 * @api private
 */
var _handleIndexDocumentTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling search indexing task.');
        }
    };

    _produceDocuments(data.tasks, function(err, allDocs) {
        if (err) {
            return callback(err);
        }

        _indexDocuments(allDocs, callback);
    });
};

var indexDocuments = module.exports.indexDocuments = function(documents, callback) {
    if (!_.isArray(documents)) {
        documents = [ documents ];
    }

    // TODO: Validate documents


    _indexDocuments(documents, callback);
};

var _indexDocuments = function(documents, callback) {
    if (documents.length > 1) {
        var ops = SearchUtil.createBulkIndexOperations(documents);
        client.bulk(ops, function(err) {
            if (!err) {
                log().info('Successfully indexed %s documents.', documents.length);
            }
            return callback(err);
        });
    } else if (documents.length === 1) {
        var doc = documents[0];
        var opts = {'parent': doc['_parent']};
        var id = doc.id;

        delete doc['_parent'];
        delete doc.id;

        client.index(doc['_type'], id, doc, opts, callback);
    } else {
        callback();
    }
};

/**
 * Produces documents that can be indexed by ElasticSearch
 *
 * @param  {IndexTask[]}    tasks       An array of indexing tasks
 * @param  {Function}       callback    Standard callback function
 * @api private
 */
var _produceDocuments = function(tasks, callback, _documents) {
    if (tasks.length === 0) {
        return callback(null, _documents);
    }

    _documents = _documents || [];

    var task = tasks.pop();

    // Pass the resource updates to the document producers to provide the top-level resources
    var searchDocumentProducer = searchDocumentProducers[task.producer] || function() {};
    searchDocumentProducer(task.data, function(err, resourceDocs) {
        if (err) {
            log().error({'err': err, 'task': task}, 'Error processing task into search documents');
            return callback(err);
        }

        if (!_.isArray(resourceDocs)) {
            resourceDocs = [resourceDocs];
        }

        // Clean up the produced documents if necessary
        resourceDocs = _.map(resourceDocs, function(doc) {
            // Allow people to create their own mappings but re-use the normal document producer mechanisme.
            var resourceMappingName = doc['_type'] ? doc['_type'] : SearchConstants.resourceMappingName;

            // Make sure we have a _type mapping
            var newDoc = _.extend({}, doc, {
                '_type': resourceMappingName,
            });

            // Stringify the _extra field, it gets parsed on the way back out
            if (newDoc._extra) {
                try {
                    newDoc._extra = JSON.stringify(newDoc._extra);
                } catch (err) {
                    log().warn({'err': err, 'doc': doc}, 'Error stringifying _extra content for document. Suppressing data');
                    delete newDoc._extra;
                }
            }

            log().trace({'before': doc, 'after': newDoc}, 'Converted resource document');

            return newDoc;
        });

        // Add the cleaned up documents into the list of already produced docs
        _documents = _documents.concat(resourceDocs);

        // Move on to the next task
        _produceDocuments(tasks, callback, _documents);
    });
};
