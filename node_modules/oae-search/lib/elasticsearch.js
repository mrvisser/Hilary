/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var ElasticSearchClient = require('elasticsearchclient');
var log = require('oae-logger').logger('elasticsearchclient');
var Telemetry = require('oae-telemetry').telemetry('search');

var index = null;
var client = null;

/**
 * Refresh the search configuration with the given options.
 *
 * @param   {String}    index       The index to use
 * @param   {Object}    serverOpts  The server opts with which to configure the client
 */
module.exports.refreshSearchConfiguration = function(indexName, serverOpts) {
    index = indexName;
    client = new ElasticSearchClient(serverOpts);
    log().info({
        config: {
            index: index,
            serverOpts: serverOpts
        }
    }, 'Refreshed search configuration.');
}

/**
 * Create an index with the specified name.
 *
 * @param {String}      indexName       The name of the index
 * @param {Object}      settings        The settings of the ElasticSearch index
 * @param {Function}    callback        Invoked when the proces completes
 * @param {Object}      callback.err    An error that occurred, if any
 */
var createIndex = module.exports.createIndex = function(indexName, settings, callback) {
    indexExists(indexName, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (!exists) {
            log().info({
                indexName: indexName,
                indexSettings: settings
            }, 'Creating new search index.');

            _exec('createIndex', client.createIndex(indexName, settings, null), callback);
        } else {
            return callback();
        }
    });
}

/**
 * Delete the index with the given name.
 *
 * @param {String}      indexName       The name of the index to delete
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var deleteIndex = module.exports.deleteIndex = function(indexName, callback) {
    indexExists(indexName, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (exists) {
            log().info('Deleting index "%s"', indexName);
            _exec('deleteIndex', client.deleteIndex(indexName, null), callback);
        } else {
            return callback();
        }
    })
}

/**
 * Determine whether or not the specified index exists.
 *
 * @param {String}      indexName       The name of the index to test
 * @param {Function}    callback        Invoked when the process completes
 * @param {Object}      callback.err    An error that occurred, if any
 * @param {Boolean}     callback.exists Whether or not the index exists
 */
var indexExists = module.exports.indexExists = function(indexName, callback) {
    _exec('indexStatus', client.status(indexName, null), function(err) {
        if (err && err.error === 'IndexMissingException[[' + indexName + '] missing]') {
            return callback(null, false);
        } else if (err) {
            return callback(err);
        } else {
            return callback(null, true);
        }
    });
}

/**
 * Refresh the current index so that all its documents are available for querying.
 *
 * @param {Function}    callback        Invoked when the process completes
 * @param {Object}      callback.err    An error that occurred, if any
 */
var refresh = module.exports.refresh = function(callback) {
    _exec('refresh', client.refresh(index, null), callback);
}

/**
 * Create a type mapping that can be searched.
 *
 * @param   {String}    typeName            The name of the type. Should be unique across the application.
 * @param   {Object}    fieldProperties     The field schema properties for the type, as per ElasticSearch mapping spec.
 * @param   {Object}    opts                Options to send with the query
 * @param   {Function}  callback            Invoked when the process completes
 * @param   {Object}    callback.err        An error that occurred, if any
 */
var putMapping = module.exports.putMapping = function(typeName, fieldProperties, opts, callback) {
    mappingExists(typeName, function(err, exists) {
        if (err) {
            return callback(err);
        }

        if (!exists) {
            var data = {};
            data[typeName] = { properties: fieldProperties };

            log().info({ typeData: data }, 'Creating new search type mapping.');

            _exec('putMapping', client.putMapping(index, typeName, data, opts), callback);
        } else {
            return callback();
        }
    });
}

/**
 * Determine whether or not the mapping exists.
 * 
 * @param   {String}    typeName        The name of the type to map.
 * @param   {Function}  callback        Invoked when the process completes.
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var mappingExists = module.exports.mappingExists = function(typeName, callback) {
    _exec('getMapping', client.getMapping(index, typeName, null), function(err, data) {
        if (err && err.error === 'TypeMissingException[[' + index + '] type[' + typeName + '] missing]') {
            return callback(null, false);
        } else if (err) {
            return callback(err);
        } else {
            return callback(null, true);
        }
    });
}

/**
 * Search ElasticSearch using the given query.
 *
 * @param   {Object}    query           The query object
 * @param   {Object}    options         Options to send with the query
 * @param   {Function}  callback        Invoked when the process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 * @param   {Object}    callback.data   The response of the query
 */
module.exports.search = function(query, options, callback) {
    log().trace({ query: query }, 'Querying elastic search.');
    return _exec('search', client.search(index, query, options), callback);
}

/**
 * Index the given document in ElasticSearch.
 *
 * @param   {String}    typeName        The type of document to index
 * @param   {Object}    doc             The document to index
 * @param   {Object}    options         The querystring options to send with the index call
 * @param   {Function}  callback        Invoked whent he process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
module.exports.index = function(typeName, doc, options, callback) {
    log().trace({ typeName: typeName, document: doc }, 'Indexing a document.');
    return _exec('index', client.index(index, typeName, doc, options), callback);
}

/**
 * Delete the document identified by the document id from the index.
 *
 * @param   {String}    typeName        The type of document to delete
 * @param   {Object}    id              The id of the document to delete
 * @param   {Function}  callback        Invoked whent he process completes
 * @param   {Object}    callback.err    An error that occurred, if any
 */
module.exports.delete = function(typeName, id, callback) {
    log().trace({ typeName: typeName, documentId: id }, 'Deleting an index document.');
    return _exec('delete', client.deleteDocument(index, typeName, id, null), callback);
}

/**
 * Execute a call to the ElasticSearchClient API.
 *
 * @param {String}              name            The name of the method
 * @param {ElasticSearchCall}   call            The call object that will be executed
 * @param {Function}            callback        Invoked when th eprocess completes
 * @param {Object}              callback.err    An error that occurred, if any
 * @param {Object}              callback.data   The search response data, if any
 */
var _exec = function(name, call, callback) {
    callback = callback || function() {};
    
    Telemetry.incr(name);
    var start = Date.now();
    var data = null;
    var err = null;

    // grab the data
    call.data(function(_data) {
        data = _data;
    });

    // when finished, call the callback with the data
    call.done(function() {
        // data should always be JSON, I think.
        try {
            data = JSON.parse(data);
            log().trace({ call: name, data: data }, 'Search execution completed.');
        } catch (ex) {
            log().trace({ call: name, data: data }, 'Search execution completed.');
            _logError(name, ex);
            return callback(new Error('Non-JSON body returned in response.'));
        }

        // ElasticSearch returns an object with an error attribute if there is an error
        if (data.error) {
            // we don't implicitly log this because it could be intended
            return callback(data);
        }

        Telemetry.appendDuration('exec.' + name + '.time', start);
        return callback(null, data);
    });

    // when there is an error, call the callback with the error
    call.error(function(err) {
        _logError(name, err);
        return callback(err);
    });

    call.exec();
}

/**
 * Logs the given error and applies telemetry udpates.
 *
 * @param {String} callName The name of the call that err'd
 * @param {Object} err      The error to log.
 */
var _logError = function(callName, err) {
    Telemetry.incr('exec.' + callName + '.error.count');
    log().error({ err: err}, 'Error executing %s query.', callName);
}
