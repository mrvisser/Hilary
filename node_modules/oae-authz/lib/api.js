/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var Cassandra = require('oae-util/lib/cassandra');
var Telemetry = require('oae-telemetry').telemetry('authz');
var Validator = require('oae-authz/lib/validator').Validator;
var AuthzUtil = require('oae-authz/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;


///////////
// ROLES //
///////////

/**
 * Determine the role assigned to the principal directly on the specified resource instance.
 * 
 * @param {String}              principalUuid   the UUID of the principal
 * @param {String}              resourceUuid    The UUID of the resource
 * @param {Function}            callback        A function specifying the role of the principal. If the principal has no role or there is an error performing the check, role will be null
 * @param {Object}              callback.err    An error that occurred, if any.
 * @param {String}              callback.role   The role of the principal on the resource
 */
var getRole = module.exports.getRole = function(principalUuid, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getRoles([principalUuid], resourceUuid, function(err, roles) {
        if (err) {
            return callback(err);
        }

        return callback(null, roles[principalUuid]);
    });
}

/**
 * Given a principal and a resource, determine all the effective roles that the principal has on the resource, by virtue of direct
 * association and indirect group inheritance.
 *
 * @param {String}       principalUuid     The UUID of the principal to check
 * @param {String}       resoureceUuid     The UUID of the resource to check
 * @param {Function}     callback          A callback function invoked when the process completes
 * @param {Object}       callback.err      An error that occurred, if any
 * @param {Object}       callback.roles    A JSON Object, keyed by all the roles the principal has on the resource. The value of all the entries is simply `true`
 */
var getAllRoles = module.exports.getAllRoles = function(principalUuid, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getAllRoles(principalUuid, resourceUuid, callback);
}

/**
 * Determines whether or not the principal has the specified role directly on the given resource.
 * 
 * @param {String}      principalUuid       The UUID of the princpals
 * @param {String}      resourceUuid        The UUID of the resource
 * @param {String}      role                The role to check
 * @param {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param {Object}      callback.err        An error that occurred, if any
 * @param {Boolean}     callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var hasRole = module.exports.hasRole = function(principalUuid, resourceUuid, role, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalUuid, resourceUuid, role, callback);
};

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param {String}          resourceUuid    the UUID of the resource
 * @param {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param {Function}        callback        Standard callback function
 * @param {Object}          callback.err    Error object, containing the error message
 */
var applyRoleChanges = module.exports.applyRoleChanges = function(resourceUuid, changes, callback) {

    var validator = new Validator();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(resourceUuid, {code: 400, msg: 'Cannot assign a role for a principal on a group resource.'}).isNotGroupResource();
    validator.check(_.keys(changes).length, {code: 400, msg: 'At least one role change needs to be applied'}).min(1);
    for (var i = 0, keys = _.keys(changes); i < keys.length; i++) {
        var principalUuid = keys[i];
        validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID specified: '+principalUuid}).isValidUuid();
        validator.check(changes[principalUuid], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();

    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _applyRoleChanges(resourceUuid, changes, callback);
};

/**
 * Get all principal roles associated to the resourceType for all the principals in the array of principalUuids. This is similar
 * to getRolesForResourceType, except it can be performed on multiple principals at once.
 * 
 * The structure of the resulting entries is structured a hash, indicating all resourceUuids that were returned and what the
 * roles associated to those resources were. For example:
 *
 * <pre>{
 *      'u:cam:simong': { 'member': true },
 *      'g:cam:group-b': { 'member': true }
 * }</pre>
 *
 * or:
 *
 * <pre>{
 *      'c:gat:Foo.docx': { 'viewer': true, 'manager': true},
 *      'c:cam:Bar.pdf':  { 'viewer': true }
 * }</pre>
 *
 * In the latter case, 'c:gat:Foo.docx' has both 'viewer' and 'manager' role associated to it. This indicates that some principal
 * had a role of 'viewer' on the resource, while some other principal had the 'manager' role.
 *
 * @param {Array}          principalUuids      The array of principalUuds to query for
 * @param {String}         resourceType        The resource type of the resources to search for, as determined by Resource.resourceType
 * @param {Number}         limit               The maximum number of resources to return per user
 * @param {Function}       callback            A function providing all the {resource uuid} -> {roles} mappings aggregated for all the provided principals queried
 * @param {Object}         callback.err        An error that occurred, if any
 * @param {Object}         callback.entries    A JSON Object representing the roles associated to the users
 * @see oae-authz#getRolesForResourceType
 */
var getRolesForPrincipalsAndResourceType = module.exports.getRolesForPrincipalsAndResourceType = function(principalUuids, resourceType, limit, callback) {
    limit = limit || 1000;
    principalUuids = principalUuids || [];

    var validator = new Validator();
    validator.check(limit, {code: 400, msg: '"limit" parameter must be a number when searching for active roles'});
    validator.check(resourceType, {code: 400, msg: 'A resourceType needs to be provided'}).notEmpty();
    validator.check(principalUuids.length, {code: 400, msg: 'At least one principal Id needs to be passed in'}).min(1);
    for (var i = 0; i < principalUuids.length; i++) {
        var principalUuid = principalUuids[i];
        validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID specified: '+ principalUuid}).isPrincipal();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var columnPrefix = resourceType+':';
    var start = columnPrefix;
    var end = start+'|';

    var cql = 'SELECT FIRST ' + limit + ' ? .. ? FROM AuthzRoles USING CONSISTENCY QUORUM WHERE principalId IN (?)';
    Cassandra.runQuery(cql, [start, end, principalUuids], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var entries = {};

        // aggregate all resources from all the rows (principals) into the entries hash
        var expandRow = function(name, value) {
            if (!entries[name]) {
                entries[name] = {};
            }
            entries[name][value] = true;
        };
        for (var i = 0; i < rows.length; i++) {
            rows[i].forEach(expandRow);
        }
        
        callback(null, entries);
    });
};

/**
 * Given a principal and a resource, determine all the roles that the principal has on the resource, by virtue of direct association and
 * indirect group inheritance.
 *
 * @param   {String}       principalUuid   The UUID of the principal to check
 * @param   {String}       resoureceUuid   The UUID of the resource to check
 * @param   {Function}     callback        A callback function invoked when the process completes
 * @param   {Object}       callback.err    An error that occurred, if any
 * @param   {Object}       callback.roles  A JSON Object, keyed by all the roles the principal has on the resource. The value of all the entries is simply `true`
 */
var _getAllRoles = function(principalUuid, resourceUuid, callback) {

    // the hash of all roles that will be aggregated
    var allRoles = {};

    // get the entire group ancestry to get the list of all principals for which we'll need to check roles
    _getGroupMembershipAncestry(principalUuid, function(err, principalUuids) {
        if (err) {
            return callback(err);
        }

        // include the current principal
        principalUuids[principalUuid] = true;
        _getRoles(_.keys(principalUuids), resourceUuid, function(err, roles) {
            if (err) {
                return callback(err);
            }

            // we need to iterate over the *values* of this roles hash to aggregate all effective roles.
            for (var p in roles) {
                if (roles.hasOwnProperty(p)) {
                    // aggregate this role into the hash
                    allRoles[roles[p]] = true;
                }
            }

            return callback(null, allRoles);
        });
    });
}

/**
 * Determine the role assigned to the given principals directly on the specified resource instance.
 * 
 * @param   {String}       principalUuid   the UUID of the principal
 * @param   {String}       resourceUuid    The UUID of the resource
 * @param   {Function}     callback        A function specifying the role of the principal. If the principal has no role or there is an error performing the check, role will be null
 * @param   {Object}       callback.err    An error that occurred, if any.
 * @param   {Object}       callback.roles  A hash keyed by principalUuid, with value set to the role they have directly on the resource 
 **/
var _getRoles = function(principalUuids, resourceUuid, callback) {
    Cassandra.runQuery('SELECT principalId, ? FROM AuthzRoles USING CONSISTENCY QUORUM WHERE principalId IN (?)', [resourceUuid, principalUuids], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // aggregate the roles for the principals
        var roles = {};
        rows.forEach(function(row) {
            var resourceCol = row.get(resourceUuid);
            var principalCol = row.get('principalId');
            if (resourceCol && resourceCol.value) {
                roles[principalCol.value] = resourceCol.value;
            }
        });

        return callback(null, roles);
    });
}

/**
 * Determines whether or not the principal has the specified role directly on the given resource.
 * 
 * @param {String}       principalUuid       The UUID of the princpals
 * @param {String}       resourceUuid        The UUID of the resource
 * @param {String}       role                The role to check
 * @param {Function}     callback            A function specifying whether or not the user has the role on the resource
 * @param {Object}       callback.err        An error that occurred, if any
 * @param {Boolean}      callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var _hasRole = function(principalUuid, resourceUuid, role, callback) {
    _getRoles([principalUuid], resourceUuid, function(err, actualRole) {
        if (err) {
            return callback(err);
        }
        callback(null, role === actualRole[principalUuid]);
    });
}

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param   {String}        resourceUuid    the UUID of the resource
 * @param   {Object}        changes         JSON object where the keys are principal ids and the values are role values
 * @param   {Function}      callback        Standard callback function
 * @param   {Object}        callback.err    Error object, containing the error message
 */
var _applyRoleChanges = function(resourceUuid, changes, callback) {
    var queries = [];
    var errors = [];

    // Variables for cache invalidation tracking:
    //  1.  If a user's role is removed or updated on a resource, its permission cache for that resource must be invalidated
    //  2.  If a group's role is removed or updated on resource, its permission cache as well as all its member descendants' permissions caches for that resource
    //      must be invalidated
    var principalsToInvalidate = {};
    var groupsToInvalidate = {};

    for (var i = 0, keys = _.keys(changes); i < keys.length; i++) {
        var principalUuid = keys[i];
        if (changes[principalUuid]) {
            queries.push({
                'query': 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                'parameters': [resourceUuid, changes[principalUuid], principalUuid]
            });
        } else if (changes[principalUuid] === false) {
            queries.push({
                'query': 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                'parameters': [resourceUuid, principalUuid]
            });
        } else {
            errors.push({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
        }
    }
    
    // invalidate this principal on this resource.
    principalsToInvalidate[principalUuid] = true;
    if (AuthzUtil.isGroupPrincipal(principalUuid)) {
        groupsToInvalidate[principalUuid] = true;
    }


    if (errors.length > 0) {
        return callback(errors[0]);
    }

    _getAllGroupMemberDescendants(_.keys(groupsToInvalidate), function(err, memberUuids) {
        if (err) {
            return callback(err);
        }

        memberUuids.forEach(function(memberUuid) {
            principalsToInvalidate[memberUuid] = true;
        });

        // apply the changes
        Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
            var errors = [];
            if (err) {
                errors.push(err);
            }

            // invalidate regardless of the result of the batch query. If it partially applied, we still don't want stale cache entries
            _cacheInvalidateResourceForPrincipals(_.keys(principalsToInvalidate), resourceUuid, function(err) {
                if (err) {
                    errors.push(err);
                }

                if (errors.length === 0) {
                    return callback();    
                } else {
                    return callback(errors[0]);
                }
            });
        });
    });
};


//////////////////////
// GROUP MEMBERSHIP //
//////////////////////

/**
 * Apply a bulk set of group memberships changes, as specified by the 'changes' parameter. The changes should
 * be a JSON Object keyed by the principal UUID, with value being the role to assign in the group. If the value
 * is 'false', then the principal should be removed from the group.
 * 
 * @param   {String}       groupUuid       The group to which the changes should be applied
 * @param   {Object}       changes         A JSON Object representing the changes to be applied. See method summary for more information.
 * @param   {Function}     callback        Standard callback, invoked when the process completes
 * @param   {Object}       callback.err    An error that occurred, if any
 */
var applyGroupMembershipChanges = module.exports.applyGroupMembershipChanges = function(groupUuid, changes, callback) {
    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided.'}).isGroupPrincipal();
    for (var i = 0, keys = _.keys(changes); i < keys.length; i++) {
        var memberUuid = keys[i];
        validator.check(memberUuid, {code: 400, msg: 'Invalid principal UUID provided: '+memberUuid}).isPrincipal();
        validator.check(changes[memberUuid], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _applyGroupMembershipChanges(groupUuid, changes, callback);
};

/**
 * Get all the members of a group.
 *
 * @param  {String}           groupUuid               An unique identifier for a group. ex: g:cam-oae-team
 * @param  {String}           start                   The principal id that comes just before the first principal you wish to have in your results.
 * @param  {Number}           limit                   The number of members you wish to retrieve.
 * @param  {Function}         callback                Standard callback method that has an array of the direct members of a group.
 * @param  {Object}           callback.err            An error that occurred, if any
 * @param  {Array<String>}    callback.members        The principal UUIDs for all members of the group
 */
var getGroupMembers = module.exports.getGroupMembers = function(groupUuid, start, limit, callback) {
    limit = limit || 100;
    callback = callback || function(err, members) {};

    var validator = new Validator();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided'}).isGroupPrincipal();
    validator.check(limit, {code: 400, msg: 'The limit parameter needs to be a number'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);

    Cassandra.runQuery("SELECT FIRST " + paging.limit + " ?..\'\' FROM AuthzGroupMembers USING CONSISTENCY QUORUM WHERE groupId = ?", [paging.start, groupUuid], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var members = [];
        var row = rows[0];
        for (var i = paging.startIndex, j = row.count; i < j; i++) {
            var name = row[i].name;
            var role = row[i].value;
            if (name !== "groupId") {
                members.push({'uuid': name, 'role': role});
            }
        }

        return callback(false, members);
    });
};

/**
 * Gets all the groups of which a principal (either user or group) is a member. This includes all group ancestors to which the user is indirectly
 * a member.
 *
 * @param {String}           principalUuid           The principal for which to retrieve all the groups
 * @param {Function}         callback                Standard callback method invoked when the process completes
 * @param {Object}           callback.err            An error that occured, if any
 * @param {String[]}         callback.groups         An (inconsistently ordered) array of groups to which the user belongs, either directly or indirectly
 */
var getMemberOf = module.exports.getMemberOf = function(principalUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided'}).isPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getGroupMembershipAncestry(principalUuid, function(err, groups) {
        if (err) {
            return callback(err);
        }
        callback(null, _.keys(groups));
    });
};

/**
 * Determines whether or not the principal (either user or group) is a member (either directly or indirectly) of the specified group.
 *
 * @param {String}            principalUuid               The principal to check
 * @param {String}            groupUuid                   The group to check
 * @param {Function}          callback                    Standard callback function, invoked when the process completes
 * @param {Object}            callback.err                An error that occurred, if any
 * @param {Boolean}           callback.isMemberOf         Specifies whether or not the principal is a member of the specified group
 */
var isMemberOf = module.exports.isMemberOf = function(principalUuid, groupUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided'}).isPrincipal();
    validator.check(groupUuid, {code: 400, msg: 'Invalid group UUID provided'}).isGroupPrincipal();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    isAllowedAny(principalUuid, groupUuid, callback);
}

/**
 * Given an array of groups, recursively get all of its children and grandchildren members.
 *
 * @param {Array<String>}               groupUuids          An array of the UUIDs of the groups to search
 * @param {Function(err, memberUuids)}  callback            Standard callback to be invoked when the process completes
 * @param {Object}                      callback.err        An error that occurred, if any
 * @param {Array<String>}               callback.memberuids All children and grandchildren group members of the provided group
 */
var _getAllGroupMemberDescendants = function(groupUuids, callback) {
    var result = {};

    var _multiGetAllGroupMemberDescendants = function(groupUuids) {
        _getGroupMembersForGroups(groupUuids, function(err, memberUuids) {
            if (err) {
                return callback(err);
            }

            var nextGroupUuidBatch = [];
            memberUuids.forEach(function(memberUuid) {
                if (!result[memberUuid] && AuthzUtil.isGroupPrincipal(memberUuid)) {
                    // first time seeing this member, we need to recurse if it is a group
                    nextGroupUuidBatch.push(memberUuid);
                }
                result[memberUuid] = true;
            });

            // if we have more groups to recurse, do it
            if (nextGroupUuidBatch.length > 0) {
                return _multiGetAllGroupMemberDescendants(nextGroupUuidBatch);
            } else {
                // nothing left to do, we're done
                return callback(null, _.keys(result));
            }
        });
    }

    _multiGetAllGroupMemberDescendants(groupUuids.slice(0));
}

/**
 * Apply a series of group membership changes. Note this internal function does no validation on the data. Please do
 * validation prior to send batches of changes to this method.
 * 
 * @param {String}                  groupUuid       The UUID of the group to which the members should be added
 * @param {Array<Object>}           changes         A JSON object keyed by a principalUuid, with value either the role to apply, or 'false' to indicate removal from the group.
 * @param {String}                  role            The role to assign to all the members
 * @param {Function(err, added)}    callback        The Function called when the process is finished
 * @param {Object}                  callback.err    An error that occurred, if any
 */
var _applyGroupMembershipChanges = function(groupUuid, changes, callback) {
    var queries = [];

    // variables for cache invalidation.
    //  1.  If a user is removed from a group, their permissions cache must be completely invalidated.
    //  2.  If a group is removed from a group, its permissions cache and all it's grandchild members' permission caches must be completely
    //      invalidated.
    //  3.  If a user's role is set/updated in a group, any existing cache entry for their role on that group resource must be invalidated
    //  4.  If a group's role is set/updated in a group, its cache entry for the parent group must be invalidated, as well as that of all
    //      of the group member descendants.
    var groupsToInvalidate = {};
    var principalsToInvalidate = {};
    var groupsToInvalidateForResource = {};
    var principalsToInvalidateForResource = {};

    _.keys(changes).forEach(function(memberUuid) {
        var role = changes[memberUuid];

        if (role === false) {

            // first, delete from AuthzGroupMembers
            queries.push({
                query: 'DELETE ? FROM AuthzGroupMembers WHERE groupId = ?',
                parameters: [memberUuid, groupUuid]
            });

            // second, delete from the AuthzRoles 
            queries.push({
                query: 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                parameters: [groupUuid, memberUuid]
            });

            principalsToInvalidate[memberUuid] = true;
            if (AuthzUtil.isGroupPrincipal(memberUuid)) {
                groupsToInvalidate[memberUuid] = true;
            }

        } else if (role) {
            // We could fill up some cache entries as a result of this, but is it worth it?

            // first, add to AuthzGroupMembers
            queries.push({
                query: 'UPDATE AuthzGroupMembers SET ? = ? WHERE groupId = ?',
                parameters: [memberUuid, role, groupUuid]
            });

            // second, add to roles
            queries.push({
                query: 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                parameters: [groupUuid, role, memberUuid]
            });

            principalsToInvalidateForResource[memberUuid] = true;
            if (AuthzUtil.isGroupPrincipal(memberUuid)) {
                groupsToInvalidateForResource[memberUuid] = true;
            }
        }
    });

    // now that we've analyzed the operations in the batch, we need to aggregate a bunch of invalidations to group member descendants
    _getAllGroupMemberDescendants(_.keys(groupsToInvalidate), function(err, descendantUuids) {
        if (err) {
            return callback(err);
        }

        // aggregate COMPLETE cache invalidations for each descendant
        descendantUuids.forEach(function(descendantUuid) {
            principalsToInvalidate[descendantUuid] = true; 
        });

        _getAllGroupMemberDescendants(_.keys(groupsToInvalidateForResource), function(err, descendantUuids) {
            if (err) {
                return callback(err);
            }

            // aggregate GROUP-ONLY cache invalidations for each descendant
            descendantUuids.forEach(function(descendantUuid) {
                principalsToInvalidateForResource[descendantUuid] = true; 
            });

            // apply the actual changes first (e.g., update the CF's of record)
            Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
                var errors = [];
                if (err) {
                    errors.push(err);
                }

                // invalidate regardless of the result of the batch query. If it partially applied, we still don't want stale cache entries
                _cacheInvalidateForPrincipals(_.keys(principalsToInvalidate), function(err) {
                    if (err) {
                        errors.push(err);
                    }
                    _cacheInvalidateResourceForPrincipals(_.keys(principalsToInvalidateForResource), groupUuid, function(err) {
                        if (err) {
                            errors.push(err);
                        }

                        if (errors.length === 0) {
                            return callback();
                        } else {
                            return callback({ code: 500, msg: errors });
                        }
                    });
                });
            });
        });
    });
}

/**
 * Given some principal, get their entire group membership ancestry. In other words, get all the groups to which they belong,
 * and the groups to all those groups belong, and so on.
 *
 * @param   {String}        principalUuid       The UUID of the principal
 * @param   {Function}      callback            A callback function specifying the entire group ancestry of the given principal
 * @param   {Object}        callback.err        The err that occured, if any
 * @param   {Object}        callback.ancestry   A hash keyed by the group UUID of each group of which the user is indirectly a member. The value of each entry is `true`.
 */
var _getGroupMembershipAncestry = function(principalUuid, callback) {
    var results = {};

    var _multiGetGroupMembershipAncestry = function(principalUuids) {
        getRolesForPrincipalsAndResourceType(principalUuids, AuthzConstants.resourceTypes.GROUP, 10000, function(err, entries) {
            if (err) {
                return callback(err);
            }

            var nextPrincipalBatch = [];
            var ancestors = Object.keys(entries);
            // for each group parent, determine if we've already recorded their membership. if not, we record it, and search it's parents
            for (var i = 0; i < ancestors.length; i++) {
                var ancestorUuid = ancestors[i];
                if (!results[ancestorUuid]) {
                    results[ancestorUuid] = true;
                    nextPrincipalBatch.push(ancestorUuid);
                }
            }

            // if we found new ancestors, we need to recurse to find their ancestors. Otherwise we're done.
            if (nextPrincipalBatch.length > 0) {
                return _multiGetGroupMembershipAncestry(nextPrincipalBatch, results);
            } else {
                return callback(false, results);
            }
        });
    }

    _multiGetGroupMembershipAncestry([principalUuid]);
};

/**
 * Get all the group members for all groups in the given list of groupUuids.
 * 
 * @param {Array<String>}               groupUuids              An array of groupUuids that specify the groups to search
 * @param {Function(err, memberUuids)}  callback                Standard callback function, invoked when the process completes
 * @param {Object}                      callback.err            An error that occurred, if any
 * @param {Array<String>}               callback.memberUuids    An aggregated array of principal UUIDs that are members of the provided groups
 */
var _getGroupMembersForGroups = function(groupUuids, callback) {
    if (!groupUuids || groupUuids.length === 0) {
        return callback(null, []);
    }

    Cassandra.runQuery('SELECT * FROM AuthzGroupMembers USING CONSISTENCY QUORUM WHERE groupId IN (?)', [groupUuids], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var memberUuids = {};
        rows.forEach(function(row) {
            row.forEach(function(name, value) {
                // weed out the key name
                if (name !== 'groupId') {
                    memberUuids[name] = true;
                }
            });
        });

        return callback(null, _.keys(memberUuids));
    });
}



/////////////////
// PERMISSIONS //
/////////////////

/**
 * Determine whether or not the principal specified by principalUuid can perform the action on the given resourceUuid
 * 
 * @param {String}          principalUuid        The principal to check
 * @param {String}          action               The action to check
 * @param {String}          resourceUuid         The resource to check
 * @param {Function}        callback             A function specifying whether or not the user can perform the operation
 * @param {Object}          callback.err         An error that occured, if any
 * @param {Boolean}         callback.isAllowed   Whether or not the principal can perform the operation on the resource
 */
var isAllowed = module.exports.isAllowed = function(principalUuid, action, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    validator.check(action, {code: 400, msg: 'Invalid action provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _isAllowed(principalUuid, action, resourceUuid, callback);
}

/**
 * Determine whether or not the principal specified by principalUuid can perform at least one action on the given resourceUuid
 *
 * @param {String}                   principalUuid      The principal to check
 * @param {String}                   resourceUuid       The resourceUuid to check
 * @param {Function(err, isAllowed)} callback           A function specifying whether or not the user can perform any operation
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not the principal is authorized to perform any action on the resource
 */
var isAllowedAny = module.exports.isAllowedAny = function(principalUuid, resourceUuid, callback) {
    var validator = new Validator();
    validator.check(principalUuid, {code: 400, msg: 'Invalid principal UUID provided.'}).isPrincipal();
    validator.check(resourceUuid, {code: 400, msg: 'Invalid resource UUID provided.'}).isValidUuid();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _isAllowed(principalUuid, null, resourceUuid, callback);
}

/**
 * Determine whether or not one of the principals in the array of principalUuids is able to perform the action on the
 * resource specified. If the action is null, then we will determine if the user can perform *any* action on the
 * resource specified.
 *
 * @param {Array<String>}            principalUuids     The array of principals to check
 * @param {String}                   action             The action to check. If null, check for any action.
 * @param {String}                   resourceUuid       The resource to check
 * @param {Function(err, isAllowed)} callback           A function invoked when the process is complete.
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not one of the principals is authorized to perform the action
 */
var _isAllowed = function(principalUuid, action, resourceUuid, callback) {

    var start = Date.now();

    // first do a single cache check on the root principal.
    _cacheGetPermissionCheck([principalUuid], action, resourceUuid, function(err, result) {
        Telemetry.append('isAllowed.cache.time', duration(start));

        if (!err && result === true) {
            Telemetry.incr('isAllowed.cache.hit.count');
            return callback(null, true);
        }

        // we don't bail if there was an error, we just check the regular source
        Telemetry.incr('isAllowed.cache.miss.count');
        start = Date.now();

        if (action === null) {
            // check to see if the principal has *any* permission on the resource
            _getRoles([principalUuid], resourceUuid, function(err, role) {
                if (err) {
                    return callback(err);
                }

                if (role[principalUuid]) {

                    // they do, cache it and call back
                    Telemetry.incr('isAllowed.direct.count');
                    Telemetry.append('isAllowed.direct.time', duration(start));
                    _cacheSetPermissionCheck(principalUuid, resourceUuid, role[principalUuid]);

                    return callback(null, true);
                }

                // they don't, delegate to ancestry
                return _ancestryIsAllowed();
            });
        } else {
            // check to see if the principal has the specified permission on the resource
            _hasRole(principalUuid, resourceUuid, action, function(err, hasRole) {
                if (err) {
                    return callback(err);
                }

                if (hasRole) {

                    // they do, cache it and call back
                    Telemetry.incr('isAllowed.direct.count');
                    Telemetry.append('isAllowed.direct.time', duration(start));
                    _cacheSetPermissionCheck(principalUuid, resourceUuid, action);

                    return callback(null, true);
                }

                // they don't, delegate to ancestry
                return _ancestryIsAllowed();
            });
        }

    });

    /**
     * Check the entire group membership ancestry of the principal in context to determine if any has
     * the request access. If a positive check is found, the callback will be executed appropriately.
     */
    var _ancestryIsAllowed = function() {
        Telemetry.incr('isAllowed.indirect.count');

        var startIndirect = Date.now();
        var start = startIndirect;

        getMemberOf(principalUuid, function(err, groupUuids) {
            if (err) {
                return callback(err);
            }

            Telemetry.append('isAllowed.memberOf.time', duration(start));
            start = Date.now();

            // short circuit if there is no ancestry
            if (groupUuids.length === 0) {
                return callback(null, false);
            }

            // grab all roles for all groups on the resource, verify it against the specified action
            _getRoles(groupUuids, resourceUuid, function(err, roles) {
                if (err) {
                    return callback(err);
                }

                Telemetry.append('isAllowed.batch.time', duration(start));

                for (var principal in roles) {
                    if (roles.hasOwnProperty(principal)) {
                        if (action === null) {
                            Telemetry.append('isAllowed.indirect.time', duration(startIndirect));
                            return callback(null, true);
                        }

                        if (roles[principal] === action) {
                            Telemetry.append('isAllowed.indirect.time', duration(startIndirect));
                            return callback(null, true);
                        }
                    }
                }

                Telemetry.append('isAllowed.indirect.time', duration(startIndirect));
                return callback(null, false);
            });
        });
    }
}



/////////////////////////
// PERMISSIONS CACHING //
/////////////////////////

/**
 * Define the representative meanings of the permissions cache values. Any value read from the cache that is not in this hash is interpreted
 * as "No value".
 */
var _CachePermissionsValue = {
    TRUE: '1'
}

/**
 * Search the permissions cache to determine if the given principals can perform the action on the specified resource.
 *
 * @param {Array<String>}           principalUuids  The principal for which to perform the permission check
 * @param {String}                  action          The permission action to verify. If null, it will check if there is *any* access rights cached
 *                                                  for the resource
 * @param {String}                  resourceUuid    The resource on which to verify the principal has access to perform the action
 * @param {Function(err, result)}   callback        Standard callback function, invoked when the process completes
 * @param {Object}                  callback.err    An error that occurred, if any
 * @param {Boolean}                 callback.result The result of the check. If true, it means that the user has the permission. If anything but
 *                                                  true (i.e., result !== true), then the cache does not have sufficient information to check that
 *                                                  the principal can perform the action. In this case, you must perform a full permission check to
 *                                                  determine the actual result.
 */
var _cacheGetPermissionCheck = function(principalUuids, action, resourceUuid, callback) {
    if (!principalUuids || principalUuids.length === 0) {
        return callback(null, null);
    }

    var permissionCheckKey = resourceUuid+':'+action;

    if (action !== null) {
        Cassandra.runQuery('SELECT ? FROM AuthzPermissionCache USING CONSISTENCY QUORUM WHERE principalId IN (?)', [permissionCheckKey, principalUuids], function(err, rows) {
            if (err) {
                return callback(err);
            }

            for (var i = 0, j = rows.length; i < j; i++) {
                var col = rows[i][0];
                if (col && col.name === permissionCheckKey) {
                    return callback(null, col.value === _CachePermissionsValue.TRUE);
                } else {
                    return callback(null, null);
                }
            }
        });
    } else {
        // if action is null, then we're checking if any of the principals have *any* access on the resource
        var start = resourceUuid + ':';
        var end = start + '|';
        Cassandra.runQuery('SELECT ? .. ? FROM AuthzPermissionCache USING CONSISTENCY QUORUM WHERE principalId IN (?)', [start, end, principalUuids], function(err, rows) {
            if (err) {
                return callback(err);
            }

            var numRows = rows.length;
            for (var i = 0; i < numRows; i++) {
                var row = rows[i];
                var numCols = row.count;
                for (var j = 0; j < numCols; j++) {
                    var col = row[j];
                    if (col.value === _CachePermissionsValue.TRUE) {
                        return callback(null, true);
                    }
                }
            }

            // if we got here, we have no positive match
            return callback(null, null);
        });
    }
}

/**
 * Invalidate (i.e., delete) all cache records for the given principals.
 *
 * @param {Array<String>}   principalUuids  The UUIDs of the principals to invalidate
 * @param {Function(err)}   callback        Standard callback function, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var _cacheInvalidateForPrincipals = function(principalUuids, callback) {
    if (!principalUuids || principalUuids.length === 0) {
        return callback();
    }
    Cassandra.runQuery('DELETE FROM AuthzPermissionCache USING CONSISTENCY QUORUM WHERE principalId IN (?)', [principalUuids], callback);
}

/**
 * Invalidate (i.e., delete) all cache records for the given principals on the specified resource.
 *
 * @param {Array<String>}   principalUuids  The UUIDs of the principals to invalidate
 * @param {String}          resourceUuid    The UUID of the resource to invalidate
 * @param {Function(err)}   callback        Standard callback function, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var _cacheInvalidateResourceForPrincipals = function(principalUuids, resourceUuid, callback) {
    if (!principalUuids || principalUuids.length === 0) {
        return callback();
    }

    var queries = [];
    var start = resourceUuid+':';
    var end = start + '|';

    // determine all the resource-role keys that will need to be deleted from the principals.
    // in practice the number should be small, 1 to 4 total or something (e.g., one for 'manager', one for 'viewer')
    Cassandra.runQuery('SELECT ?..? FROM AuthzPermissionCache USING CONSISTENCY QUORUM WHERE principalId IN (?)', [start, end, principalUuids], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // aggregate all known resource role keys (e.g., 'c:cam:Foo.docx:manager')
        var resourceActionKeys = {};
        rows.forEach(function(row) {
            row.forEach(function(name) {
                resourceActionKeys[name] = true;
            });
        });

        // build and execute the delete query
        var params = [];
        var placeholders = [];
        _.keys(resourceActionKeys).forEach(function(resourceActionKey) {
            placeholders.push('?');
            params.push(resourceActionKey);
        });
        params.push(principalUuids);

        if (placeholders.length > 0) {
            Cassandra.runQuery('DELETE ' + placeholders.join(',') + ' FROM AuthzPermissionCache USING CONSISTENCY QUORUM WHERE principalId IN (?)', params, callback);
        } else {
            // no one had any cached permissions on the resource.
            return callback();
        }
    });
}

/**
 * Set the value of a permission check for a given principal on a resource. After this has been performed, subsequent checks to the cache for this principal, resource, and
 * action will be true. If the cache is invalidated for the principal on the resource, or for the principal entirely, this cache entry will be deleted.
 *
 * @param {Array<String>}   principalUuids  The principal whose permission to set
 * @param {String}          resourceUuid    The the resource on which to set the permission
 * @param {String}          action          The permission to set
 * @param {Function(err)}   callback        Standard callback function, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var _cacheSetPermissionCheck = function(principalUuid, resourceUuid, action, callback) {
    callback = callback || function() {};
    var resourceActionKey = resourceUuid + ':' + action;
    Cassandra.runQuery('UPDATE AuthzPermissionCache USING CONSISTENCY QUORUM SET ? = ? WHERE principalId = ?', [resourceActionKey, _CachePermissionsValue.TRUE,
        principalUuid], callback);
}



///////////////////////////////
// ADDITIONAL HELPER METHODS //
///////////////////////////////

/**
 * Return the duration in milliseconds from the `from` time to now.
 *
 * @param   {Number} from   The starting point (millis since epoch) from which to calculation the duration
 * @return  {Number}        The number of milliseconds between the `from` time and now.
 */
var duration = function(from) {
    return Date.now() - from;
}
