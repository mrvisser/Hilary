/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-authz');
var Validator = require('oae-authz/lib/validator').Validator;
var AuthzUtil = require('oae-authz/lib/util');


//////////////////////
// GROUP MEMBERSHIP //
//////////////////////

/**
 * Apply a bulk set of group memberships changes, as specified by the 'changes' parameter. The changes should
 * be a JSON Object keyed by the principal ID, with value being the role to assign in the group. If the value
 * is 'false', then the principal should be removed from the group.
 * 
 * @param {String}          authzGroupId    The group to which the changes should be applied
 * @param {Object}          changes         A JSON Object representing the changes to be applied. See method summary for more information.
 * @param {Function(err)}   callback        Standard callback, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var applyAuthzGroupMembershipChanges = module.exports.applyAuthzGroupMembershipChanges = function(authzGroupId, changes, callback) {
    var validator = new Validator();
    validator.check(authzGroupId, {code: 400, msg: 'Invalid authz group ID provided.'}).isAuthzGroupId();
    for (var i = 0; i < _.keys(changes).length; i++) {
        var memberId = _.keys(changes)[i];
        validator.check(memberId, {code: 400, msg: 'Invalid authz principal ID provided: '+memberId}).isAuthzPrincipalId();
        validator.check(changes[memberId], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _applyGroupMembershipChanges(authzGroupId, changes, callback);
};

/**
 * Get the direct members of a group and their role.
 *
 * @param  {String}                     authzGroupId            An unique identifier for a group. ex: g:cam-oae-team
 * @param  {Object}                     opts                    An object holding optional parameters
 * @param  {String}                     opts.start              The principalId that comes just before the first principal you wish to have
 *                                                              in your results. By default, results will start always from the beginning.
 * @param  {Number}                     opts.limit              The number of members you wish to retrieve. Defaults to 100.    
 * @param  {Function(err, memberships)} callback                Standard callback method that has an array of the direct members of a group.
 * @param  {Object}                     callback.err            An error that occurred, if any
 * @param  {Array<Object>}              callback.members        A JSON object representing the group members. Each object in the array
 *                                                              contains property 'principalId' and 'role'.
 */
var getAuthzGroupMembers = module.exports.getAuthzGroupMembers = function(authzGroupId, opts, callback) {
    opts.limit = opts.limit || 100;
    callback = callback || function(err, members) {};

    var validator = new Validator();
    validator.check(authzGroupId, {code: 400, msg: 'Invalid group ID provided'}).isAuthzId();
    validator.check(opts.limit, {code: 400, msg: 'The limit parameter needs to be a number'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Page the query.
    var paging = Cassandra.getPagingParameters(opts.start, opts.limit);

    Cassandra.runQuery("SELECT FIRST " + paging.limit + " ?..\'\' FROM AuthzGroupMembers USING CONSISTENCY QUORUM WHERE groupId = ?", [paging.start, authzGroupId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var members = [];
        var row = rows[0];
        for (var i = paging.startIndex, j = row.count; i < j; i++) {
            var name = row[i].name;
            var role = row[i].value;
            if (name !== "groupId") {
                memberships.push({'principalId': name, 'role': role});
            }
        }

        return callback(null, memberships);
    });
};

/**
 * Gets all the authz groups of which a principal is a member. This includes all group ancestors to which the principal is indirectly
 * a member. The result is an unordered array of hashes that are keyed by the groupId, and the value is another hash that holds a unique
 * set of roles the user has on the respective group. For example:
 *
 *  {
 *      'g:cam:cool-people': {          // someone is both the mayor and a citizen of the 'cool-people' group
 *          'mayor': true,
 *          'citizen': true
 *      },
 *
 *      'g:oae:oae-backend-team': {     // this person is also a member of the OAE backend team
 *          'member': true
 *      },
 *
 *      'g:world:canadians': {          // this person is a canadian, hmmm, which canadian on the backend team is the mayor of cool people?
 *          'citizen': true
 *      }
 * }
 *
 * @param {String}                  authzPrincipalId        The principal for which to retrieve all the groups
 * @param {Object}                  opts                    Object containing optional parameters for the search
 * @param {String}                  opts.filterBy           A group type that, if specified, will filter the group memberhip graph to only
 *                                                          traverse and include groups of this type
 * @param {Function(err, groups)}   callback                Standard callback method invoked when the process completes
 * @param {Object}                  callback.err            An error that occured, if any
 * @Param {Array<Object>}           callback.memberships    An (inconsistently ordered) array of JSON Objects that represent the principal's
 *                                                          group membership info. The key is the groupId, while the value is another JSON
 *                                                          that enumerates all the roles the user has in the group, as determined by group
 *                                                          membership.
 */
var getAllAuthzGroupMemberships = module.exports.getAllAuthzGroupMemberships = function(authzPrincipalId, opts, callback) {
    var validator = new Validator();
    validator.check(authzPrincipalId, {code: 400, msg: 'Invalid principal ID provided'}).isAuthzId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var memberships = {};
    var forEach = function(currentMemberships) {
        // aggregate all new memberships into the aggregating memberships hash
        for (var groupId in currentMemberships) {
            if (currentMemberships.hasOwnProperty(groupId)) {
                if (!memberships[groupId]) {
                    memberships[groupId] = {};
                }
                _.extend(memberships[groupId], currentMemberships[groupId]);
            }
        }
        return true;
    }

    _traverseAuthzGroupMembershipAncestry(authzPrincipalId, opts.filterBy, forEach, function(err) {
        if (err) {
            return callback(err);
        }
        return callback(null, memberships);
    });
};

/**
 * Determine all groups of which the given principal is a direct member.
 *
 * @param {String}                      authzPrincipalId        The ID of the principal
 * @param {Object}                      opts                    A set of optional parameters to determine how this method should execute
 * @param  {String}                     opts.start              The principalId that comes just before the first principal you wish to have
 *                                                              in your results. By default, results will start always from the beginning.
 * @param  {Number}                     opts.limit              The number of members you wish to retrieve. Defaults to 100.                  
 * @param {String}                      opts.filterBy           Filter the groups returned by this type. If not specified, then all groups
 *                                                              will be returned
 * @param {Function(err, memberships)}  callback                Standard callback fucntion, invoked when the process completes
 * @param {Object}                      callback.err            An error that occurred, if any
 * @param {Array<Object>}               callback.memberships    A consistently ordered array of membership objects, describing the principal's
 *                                                              membership in each group. The key 'groupId' holds the ID of the group, and the
 *                                                              key 'role' is the role the principal has in the group
 */
var getAuthzGroupMemberships = module.exports.getAuthzGroupMemberships = function(authzPrincipalId, opts, callback) {
    var validator = new Validator();
    validator.check(authzPrincipalId, {code: 400, msg: 'Invalid principal ID provided'}).isAuthzId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // the beginning and end as constrained by the filter, if any
    var filterStart = opts.filterBy ? opts.filterBy + ':' : null;
    var filterEnd = opts.filterBy ? opts.filterBy + ':|' : '';

    // Page the query.
    var paging = Cassandra.getPagingParameters(opts.start, opts.limit, filterStart);

    var cql = null;
    var params = null;
    if (opts.filterBy) {
        cql = 'SELECT FIRST ' + paging.limit + ' ? .. ? FROM AuthzMemberOf USING CONSISTENCY QUORUM WHERE groupId = ?';
        params = [paging.start, filterEnd, authzPrincipalId];
    } else {
        // we need to increment the paging limit by one and handle it when aggregating the results. this is because the 'groupId'
        // may turn up in the results here.
        paging.limit++;
        cql = 'SELECT FIRST ' + (paging.limit+1) + ' * FROM AuthzMemberOf USING CONSISTENCY QUORUM WHERE groupId = ?';
        params = [authzPrincipalId];
    }

    Cassandra.runQuery(cql, params, function (err, rows) {
        if (err) {
            return callback(err);
        }

        var memberships = [];
        var row = rows[0];

        // TODO: Verify there is very good 'one-off' test coverage for these acrobatics to avoid index out of bounds exceptions.

        // j = row.count-1 is set because we'll start assuming that we won't run into 'groupId'. If we do, we increment 'j' to make up for
        // the lost item in the page. this will never happen if we're doing a filtered query.
        for (var i = paging.startIndex, j = row.count-1; i < j; i++) {
            var groupId = row[i].name;
            var role = row[i].value;
            if (groupId !== 'groupId') {
                memberships.push({'groupId': groupId, 'role': role});
            } else {
                // we hit 'groupId', grab just one more column to make up for that
                j++;
            }
        }

        return callback(null, memberships);
    });
}

/**
 * Determines whether or not the principal (either user or group) is a member (either directly or indirectly) of the specified group.
 *
 * @param {String}                      authzPrincipalId            The principal to check
 * @param {String}                      authzGroupId                The group to check
 * @param {String}                      opts                        Optional parameters
 * @param {Boolean}                     opts.filter                 Specifies to filter authz group memberships that are only of the same type
 *                                                                  as the provided authzGroupId. Defaults to false.
 * @param {String}                      opts.role                   If specified, will determine if the user has the given role in the group.
 *                                                                  If not specified, the check will determine if the user has *any* role in
 *                                                                  the group
 * @param {Function(err, isMemberOf)}   callback                    Standard callback function, invoked when the process completes
 * @param {Object}                      callback.err                An error that occurred, if any
 * @param {Boolean}                     callback.isMemberOf         Specifies whether or not the principal is a member of the specified group
 */
var isMemberOf = module.exports.isMemberOf = function(authzPrincipalId, authzGroupIds, opts, callback) {
    var validator = new Validator();
    validator.check(authzPrincipalId, {code: 400, msg: 'Invalid authz principal ID provided'}).isAuthzId();
    validator.check(authzGroupId, {code: 400, msg: 'Invalid authz group ID provided'}).isAuthzId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var isMemberOf = false;
    var filterBy = opts.filter ? new AuthzId(authzGroupId).type : null;
    var nextIteration = function(memberships) {
        if (opts.role && opts.role === memberships[authzGroupId]) {
            // user had the specified role in the group somewhere in the hierarchy
            isMemberOf = true;
            return false;
        } else if (!opts.role && memberships[authzGroupId]) {
            // user had any role in the somewhere in the hierarchy
            isMemberOf = true;
            return false;
        }

        // no explicit match, continue on
        return true;
    }

    // TODO: store this exploded
    _traverseAuthzGroupMembershipAncestry(authzPrincipalId, filterBy, nextIteration, function(err) {
        if (err) {
            return callback(err);
        }
        return callback(null, isMemberOf);
    });
}

/**
 * Apply a bulk set of group memberships changes, as specified by the 'changes' parameter. The changes should be a JSON Object keyed by the
 * principal ID, with value being the role to assign in the group. If the value is 'false', then the principal should be removed from the
 * group.
 * 
 * @param {String}          authzGroupId    The group to which the changes should be applied
 * @param {Object}          changes         A JSON Object representing the changes to be applied. See method summary for more information.
 * @param {Function(err)}   callback        Standard callback, invoked when the process completes
 * @param {Object}          callback.err    An error that occurred, if any
 */
var _applyAuthzGroupMembershipChanges = function(authzGroupId, changes, callback) {
    var queries = [];
    var memberIds = _.keys(changes);

    for (var i = 0; i < memberIds.length; i++) {
        var memberId = memberIds[i];
        var role = changes[memberId];

        if (role === false) {

            // first, delete from AuthzGroupMembers
            queries.push({
                query: 'DELETE ? FROM AuthzGroupMembers WHERE groupId = ?',
                parameters: [memberId, authzGroupId]
            });

            // second, delete from the AuthzMemberOf column family 
            queries.push({
                query: 'DELETE ? FROM AuthzMemberOf WHERE principalId = ?',
                parameters: [authzGroupId, memberId]
            });

        } else if (role) {

            // first, add to AuthzGroupMembers
            queries.push({
                query: 'UPDATE AuthzGroupMembers SET ? = ? WHERE groupId = ?',
                parameters: [memberId, role, authzGroupId]
            });

            // second, add to AuthzMemberOf
            queries.push({
                query: 'UPDATE AuthzMemberOf SET ? = ? WHERE principalId = ?',
                parameters: [authzGroupId, role, memberId]
            });

        }
    }

    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (!err) {
            callback(null, memberIds);
        } else {
            callback(err);
        }
    });
};

/**
 * Given some principal, traverse their entire group ancestry one level of depth at a time. By specifying the forEach function, the caller
 * may perform operations based on the group ancestry, and short-circuit the process when necessary. See parameter information for more
 * details.
 *
 * @param {String}                  authzPrincipalId    The ID of the principal
 * @param {String}                  filterBy            Specifies what, if any, group type the graph traversal should be filtered by
 * @param {Function(memberships)}   forEach             A function that is executed at each level of depth in the group traversal. If this
 *                                                      function returns true, traversal will continue. If it returns false, traversal will
 *                                                      stop and the callback function will be executed. If not specified, traversal will
 *                                                      not break until all ancestors have been exhausted.
 * @param {Array<Object>}           forEach.memberships An array of memberships discovered at the current level of traversal depth.
 * @param {Function(err, ancestry)} callback            A callback function specifying the entire group ancestry of the given principal
 * @param {Object}                  callback.err        The err that occured, if any
 */
var _traverseAuthzGroupMembershipAncestry = function(authzPrincipalId, filterBy, forEach, callback) {
    forEach = forEach || function() { return true; };
    filterBy = filterBy ? filterBy + ':' : null;

    // maintain a hash to represent principals already traversed
    var visited = {};

    // stats
    var stats = {
        depth: 0,
        start: new Date(),
        uniqueMemberships: 0,
        uniquePrincipals: 0
    };

    var depth = 0;
    var totalUniqueMemberships = 0;
    var totalPrincipalsQueried = 0;

    var _multiTraverseAuthzGroupMembershipAncestry = function(authzPrincipalIds) {
        var query = null;
        var params = [];
        if (filterBy) {
            query = 'SELECT ? .. ? FROM AuthzMemberOf USING CONSISTENCY QUORUM WHERE principalId IN (?)';
            params = [filterBy, filterBy + '|', authzPrincipalIds];
        } else {
            query = 'SELECT * FROM AuthzMemberOf USING CONSISTENCY QUORUM WHERE principalId IN (?)';
            params = [authzPrincipalIds];
        }

        var memberships = {};
        var nextPrincipalBatch = {};

        Cassandra.runQuery(query, params, function(err, rows) {
            if (err) {
                log().error({err : err}, 'Unexpected exception while traversing group hierarchy.');
                logTraversalStats('error', stats);
                return callback(err);
            }

            // aggregate the newly visisted principals and their roles
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                row.forEach(function(memberId, role) {

                    // regardless of whether or not we've already visisted this member, we need to report this visit to the
                    // forEach because the same principal may have multiple roles by virtue of multiple group memberships
                    memberships[memberId] = role;

                    // only if we haven't visited this member, queue them to be re-queried
                    if (!visited[memberId]) {
                        nextPrincipalBatch[memberId] = true;
                        visited[memberId] = true;
                    }
                });
            };

            // if we didn't find any memberships, don't trigger the forEach with empty memberships, we're done
            var membershipsKeys = _.keys(memberships);

            // record traversal stats
            stats.depth++;
            stats.uniqueMemberships += membershipsKeys.length;
            stats.uniquePrincipals += authzPrincipalIds.length;

            if (membershipsKeys.length > 0) {
                try {
                    // safely execute this forEach
                    var result = forEach(memberships);
                    if (result) {
                        // only continue if we have more principals to traverse
                        var nextPrincipalBatchKeys = _.keys(nextPrincipalBatch);
                        if (nextPrincipalBatchKeys.length > 0) {
                            return _multiTraverseAuthzGroupMembershipAncestry(nextPrincipalBatchKeys);
                        } else {
                            logTraversalStats('exhausted', stats);
                            return callback();
                        }
                    } else {
                        logTraversalStats('short-circuited', stats);
                        return callback();
                    }
                } catch (err) {
                    log().error({err : err}, 'Unexpected exception while traversing group hierarchy.');
                    logTraversalStats('error', stats);
                    return callback(err);
                }
            } else {
                logTraversalStats('exhausted', stats);
                return callback();
            }
        });
    }

    _multiTraverseAuthzGroupMembershipAncestry([authzPrincipalId]);
};

/////////////////
// PERMISSIONS //
/////////////////

/**
 * Get all the actions the principal is able to perform on the group.
 */
var getAllMembershipRoles = module.exports.getAllMembershipRoles = function(authzPrincipalId, authzGroupId, opts, callback) {
    // TODO: Optimize this with exploding

}

/**
 * Determine whether or not the principal specified by authzPrincipalId can perform the action on the given authzGroupId
 * 
 * @param {String}                   authzPrincipalId   The principal to check
 * @param {String}                   action             The action to check
 * @param {String}                   authzGroupId       The resource to check
 * @param {Function(err, isAllowed)} callback           A function specifying whether or not the user can perform the operation
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not the principal can perform the operation on the resource
 */
var isAllowed = module.exports.isAllowed = function(authzPrincipalId, action, authzGroupId, callback) {
    // first check this principal directly
    _getDirectMembership(authzPrincipalId, authzGroupId, function(err, role) {
        if (err) {
            return callback(err);
        }

        if (action === role) {
            return callback(null, true);
        } else {
            // get the entire (indirect as well) group ancestry of the principal and check if they have the access

            // TODO: There is a potential optimization here to not aggressively get all ancestors, but rather check one level at a time
            // We can do the above optimization assuming we can short-circuit the checks when we get one positive check.
            getMemberOf(authzPrincipalId, function(err, authzGroupIds) {
                if (!err) {
                    return _isAllowed(authzGroupIds, action, authzGroupId, callback);
                } else {
                    return callback(err);
                }
            });
        }
    });
}

/**
 * Determine whether or not the principal specified by authzPrincipalId can perform at least one action on the given authzGroupId
 *
 * @param {String}                   authzPrincipalId      The principal to check
 * @param {String}                   authzGroupId       The authzGroupId to check
 * @param {Function(err, isAllowed)} callback           A function specifying whether or not the user can perform any operation
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not the principal is authorized to perform any action on the resource
 */
var isAllowedAny = module.exports.isAllowedAny = function(authzPrincipalId, authzGroupId, callback) {
    // first check the principal directly
    getRole(authzPrincipalId, authzGroupId, function(err, role) {
        if (!err) {
            if (role) {
                // there was a role, short-circuit and indicate that the user has some role on the resource
                return callback(null, true);
            } else {
                getMemberOf(authzPrincipalId, function(err, authzGroupIds) {
                    if (!err) {
                        return _isAllowed(authzGroupIds, null, authzGroupId, callback);
                    } else {
                        return callback(err);
                    }
                });
            }
        } else {
            return callback(err);
        }
    });
}

/**
 * Determine whether or not one of the principals in the array of authzPrincipalIds is able to perform the action on the
 * resource specified. If the action is null, then we will determine if the user can perform *any* action on the
 * resource specified.
 *
 * @param {Array<String>}            authzPrincipalIds     The array of principals to check
 * @param {String}                   action             The action to check. If null, check for any action.
 * @param {String}                   authzGroupId       The resource to check
 * @param {Function(err, isAllowed)} callback           A function invoked when the process is complete.
 * @param {Object}                   callback.err       An error that occured, if any
 * @param {Boolean}                  callback.isAllowed Whether or not one of the principals is authorized to perform the action
 */
var _isAllowed = function(authzPrincipalIds, action, authzGroupId, callback) {

    // short circuit if there is no ancestry
    if (!(authzPrincipalIds.length > 0)) {
        return callback(null, false);
    }

    // variables for monitoring the progress of permissions checks
    var index = 0;
    var isAllowedResult = false;
    var errResult = false;

    // this function monitors the progress of asynchronous permissions checks, calling back to the caller when appropriate
    var checkStatus = function(err, isAllowed) {
        if (errResult || isAllowedResult) {
            // do nothing, because we've already finished executing and called the callback
        } else if (err) {
            // we got an error while executing, call back with the error
            errResult = err;
            return callback(errResult);
        } else if (isAllowed) {
            // one of the principals is allowed to perform the action, short circuit
            isAllowedResult = isAllowed;
            return callback(null, isAllowedResult);
        } else {
            index++;
            if (index >= authzPrincipalIds.length) {
                // we've reached the end of the check and none are allowed, return false
                return callback(null, false);
            }
        }
    };

    // invoke the entire ancestry asynchronously. checkStatus will determine the result and when it is possible to call back.
    for (var i = 0; i < authzPrincipalIds.length; i++) {
        var authzPrincipalId = authzPrincipalIds[i];
        if (action !== null) {
            hasRole(authzPrincipalId, authzGroupId, action, checkStatus);
        } else {
            // we pass checkStatus directly here on the basis that the 'isAllowed' parameter is a duck-check and not strictly typed.
            getRole(authzPrincipalId, authzGroupId, checkStatus);
        }
    }
};

var _getDirectMembership(authzPrincipalId, authzGroupId, callback) {
    Cassandra.runQuery('SELECT ? FROM AuthzMemberOf USING CONSISTENCY QUORUM WHERE principalId = ?', [authzGroupId, authzPrincipalId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var row = rows[0];
        if (row.count > 0) {
            return callback(null, row[0].value);
        } else {
            return callback(null, null);
        }
    });
}

/**
 * Output group membership ancestry traversal data to the logs.
 * 
 * @param {String} reason   The reason for ending the traversal. Can be any string. E.g, 'exhausted', 'error', 'short-circuit'
 */
var logTraversalStats(reason, stats) {
    var now = new Date();
    log().debug('Finished traversing group memberships ancestry with reason: "%s". Traversed a depth of %d, aggregating %d unique memberships and visiting %d unique principals in %sms',
        reason, stats.depth, stats.uniqueMemberships, stats.uniquePrincipals, now-stats.start);
}
