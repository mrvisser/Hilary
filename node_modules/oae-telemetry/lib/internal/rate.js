/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var events = require('events');
var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-telemetry-rate');
var OaeUtil = require('oae-util/lib/util');

var telemetryRateConfig = null;
var redisClient = null;
var collectInterval = null;

/**
 * TelemetryRate module is responsible for aggregating arbitrary counts, and collecting them on a regular interval so they
 * may be published to an external metric analyzer.
 *
 * ## Events
 *
 * * `publish(counts, [ageInMillis])` - Emitted when the node has data that should be published to a metric analyzer. `counts` is an object whose key is the metric key and the value is the number of times invoked in this interval. The `ageInMillis` is the last time the metrics were reset so that a rate summary may be derived.
 */
var TelemetryRate = module.exports = new events.EventEmitter();

/**
 * Initialize the telemetry rate monitor utility.
 *
 * @param  {Object}         telemetryRateConfig     The configuration values for the rate monitor utility
 * @param  {RedisClient}    redisClient             The redis client to use for storing counts
 */
var init = module.exports.init = function(_telemetryRateConfig, _redisClient) {
    telemetryRateConfig = _createConfig(_telemetryRateConfig);
    redisClient = _redisClient;

    clearTimeout(collectInterval);
    collectInterval = setInterval(_collectAndReset, _telemetryRateConfig.collectionCheckInterval * 1000);

    // Set the start of the collection interval to mark the beginning, if one doesn't exist yet
    redisClient.setnx(_getRateTimestampKey(), Date.now());
};

/**
 * Increment a count key to count the occurrence of something
 *
 * @param  {String}     key         The key to increment (e.g., some metric you wish to count)
 * @param  {Number}     [count]     The number of units to increment. Default: 1
 */
var incr = module.exports.incr = function(key, count, callback) {
    callback = callback || function(err) {
        if (err) {
            return log().error({'err': err, 'key': key, 'count': count}, 'An error occurred trying to increment a count');
        }
    };

    // If the count is ommitted from params (i.e., undefined), it defaults to 1. However if someone tosses in a value of 0 or null,
    // we want to complain about it
    if (count === undefined) {
        count = 1;
    }

    // Suppress invalid (i.e., non-undefined) values for count
    var realCount = OaeUtil.getNumberParam(count, 1, 1);
    if (realCount != count) {
        log().warn('Suppressing invalid increment value of "%s"', count);
        return;
    }

    redisClient.hincrby(_getRateCountKey(), key, count);
    return;
};

/**
 * Collect and reset the rate of incrementation for each count key. The result of this method is not a callback or a return, but
 * rather emitting the 'publish' event of the module if there is rate information to be published.
 *
 * @api private
 */
var _collectAndReset = function() {
    log().trace('Checking for rate telemetry');
    // The lock itself is what controls other nodes from publishing more frequent than the publish interval, so while we
    // acquire this lock, we never actually release it. We just let it expire after the collection publish interval
    // and someone else will steal it when it's expired.
    Locking.acquire(_getRateLockKey(), telemetryRateConfig.collectionPublishInterval, function(err, token) {
        if (err) {
            return log().error({'err': err}, 'Error trying to acquire lock from redis');
        } else if (!token) {
            return log().trace('Not scheduled to publish telemetry results at this time');
        }

        var hashKey = _getRateCountKey();

        var multi = redisClient.multi();
        multi.getset(_getRateTimestampKey(), Date.now());   // Get the last publish time and set the new one for next collection
        multi.hgetall(hashKey);                             // Get all the counts incremented in this collection interval
        multi.del(hashKey);                                 // Reset all the counts for the next interval
        multi.exec(function(err, lines) {
            if (err) {
                return log().error({'err': err}, 'Error executing count collection command against redis');
            }

            log().trace({'lines': lines}, 'Received multi-exec response from redis');

            // First line is the result of the getset on the timestamp
            var ageInMillis = lines[0];
            var countsArray = lines[1];
            var counts = {};

            if (countsArray) {
                for (var i = 0; i < countsArray.length; i++) {
                    // Every odd line is a key, every even line is the value associated to the key above it
                    counts[lines[i]] = lines[++i];
                }
            }

            log().trace({'ageInMillis': ageInMillis, 'counts': counts}, 'Collected telemetry rate counts');
            return TelemetryRate.emit('publish', counts, ageInMillis);
        });
    });
};

/**
 * @return the redis key to use for the rate "last reset" timestamp
 * @api private
 */
var _getRateTimestampKey = function() {
    return 'oae-telemetry:rate:lastReset';
};

/**
 * @return the redis key to use for the rate collection lock
 * @api private
 */
var _getRateLockKey = function() {
    return 'oae-telemetry:rate:collectLock';
};

/**
 * @return the redis key to use for the inrementing counts hash entry
 * @api private
 */
var _getRateCountKey = function() {
    return 'oae-telemetry:rate:counts';
};

/**
 * Create the configuration object for rate collection based on the user config.
 *
 * @param  {Object}     telemetryRateConfig     The user-supplied telemetry rate configuration
 * @return {Object}                             The telemetry rate configuration to use, after applying defaults and constraints
 */
var _createConfig = function(_telemetryRateConfig) {
    _telemetryRateConfig = _telemetryRateConfig || {};
    return {
        'collectionCheckInterval': OaeUtil.getNumberParam(_telemetryRateConfig.collectionCheckInterval, 30, 1),
        'collectionPublishInterval': OaeUtil.getNumberParam(_telemetryRateConfig.collectionPublishInterval, 60, 1)
    };
};
