/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-activity');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;

// Time-to-live for activities is 2 weeks (in seconds). They disappear from feeds after that time.
var DEFAULT_TTL = 2 * 7 * 24 * 60 * 60;

var ttl = null;

/**
 * Refresh the configuration of the DAO.
 *
 * @param   {Number}    [activityTtl]   The time-to-live (in seconds) for generated activities. Defaults to 2 weeks.
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(activityTtl) {
    ttl = (!activityTtl || isNaN(activityTtl)) ? DEFAULT_TTL : activityTtl;
};

var getActivityByKey = module.exports.getActivityByKey = function(activityStreamId, activityKey, callback) {
    Cassandra.runQuery('SELECT ? FROM ActivityStreams USING CONSISTENCY ONE WHERE activityStreamId = ?', [activityKey, activityStreamId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var activities = _rowToActivities(rows[0]);
        return callback(null, activities[0]);
    });
};

/**
 * Get a list of activities from the specified activity stream.
 *
 * @param   {String}        activityStreamId    The ID of the activity stream
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivities = module.exports.getActivities = function(activityStreamId, start, limit, callback) {
    limit = limit || 25;
    var paging = Cassandra.getPagingParameters(start, limit);
    var activities = [];

    // Selecting with consistency ONE as having great consistency is not critical for activities
    Cassandra.runQuery('SELECT FIRST ? ? .. \'\' FROM ActivityStreams USING CONSISTENCY ONE WHERE activityStreamId = ?', [paging.limit, paging.start, activityStreamId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        return callback(null, _rowToActivities(rows[0]));
    });
};

/**
 * Save an activity to a list of routes.
 *
 * @param   {String}    activityKey     The unique key with which the activity will be keyed in the activity streams
 * @param   {Object}    routeActivities A hash, mapping route -> Activity, outlining which activities should be saved to which routes
 * @param   {Function}  [callback]      Invoked when the process completes
 * @param   {Object}    [callback.err]  An error that occurred, if any
 */
var saveActivities = module.exports.saveActivities = function(activityKey, routeActivities, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error saving routes to database.');
        }
    };
    
    var queries = [];
    var routes = _.keys(routeActivities);
    for (var i = 0; i < routes.length; i++) {
        var route = routes[i];
        var activity = routeActivities[route];
        var activityStr = JSON.stringify(activity);
        queries.push({
            'query': 'UPDATE ActivityStreams USING TTL ' + ttl + ' SET ? = ? WHERE activityStreamId = ?',
            'parameters': [activityKey, activityStr, route]
        });
    }

    // Saving activities with consistency ONE because consistency is not critical for activities
    Cassandra.runBatchQuery(queries, 'ONE', callback);
};

var getAggregateLastModifiedByKeys = module.exports.getAggregateLastModifiedByKeys = function(aggregateKeys, callback) {
    var aggregatesLastModified = {};

    if (aggregateKeys.length === 0) {
        return callback(null, aggregatesLastModified);
    }

    Cassandra.runQuery('SELECT lastModified FROM ActivityAggregationStatus USING CONSISTENCY ONE WHERE aggregateKey IN (?)', [aggregateKeys], function(err, rows) {
        if (err) {
            return callback(err);
        }

        rows.forEach(function(row) {
            if (row.get('lastModified')) {
                var lastModified = parseInt(row.get('lastModified').value, 10);
                if (!isNaN(lastModified)) {
                    aggregatesLastModified[row.key] = lastModified;
                }
            }
        });

        return callback(null, aggregatesLastModified);
    });
};

var saveAggregates = module.exports.saveAggregates = function(routeAggregateKeys, streamUpdates, callback) {
    var routes = _.keys(routeAggregateKeys);
    var queries = [];
    var now = Date.now();
    routes.forEach(function(route) {
        var streamUpdate = streamUpdates[route];
        var published = streamUpdate.published;
        var verb = streamUpdate.verb;
        var actor = streamUpdate.actor;
        var object = streamUpdate.object;
        var target = streamUpdate.target;

        routeAggregateKeys[route].forEach(function(aggregateKey) {

            // Add the aggregate status
            queries.push({
                'query': 'UPDATE ActivityAggregationStatus SET lastModified = ?, published = ?, verb = ?  WHERE aggregateKey = ?',
                'parameters': [now, published, verb, aggregateKey]
            });

            // Append the actor, object and target entities
            if (actor) {
                queries.push({
                    'query': 'UPDATE ActivityAggregation SET ? = ? WHERE aggregateKey = ?',
                    'parameters': [actor[ActivityConstants.properties.OAE_ID], JSON.stringify(actor), aggregateKey + '#actor']
                });
            }

            if (object) {
                queries.push({
                    'query': 'UPDATE ActivityAggregation SET ? = ? WHERE aggregateKey = ?',
                    'parameters': [object[ActivityConstants.properties.OAE_ID], JSON.stringify(object), aggregateKey + '#object']
                });
            }

            if (target) {
                queries.push({
                    'query': 'UPDATE ActivityAggregation SET ? = ? WHERE aggregateKey = ?',
                    'parameters': [target[ActivityConstants.properties.OAE_ID], JSON.stringify(target), aggregateKey + '#target']
                });
            }
        });
    });

    Cassandra.runBatchQuery(queries, 'ONE', callback);
};

var setAggregatesActive = module.exports.setAggregatesActive = function(aggregateKeys, callback) {
    Cassandra.runQuery('UPDATE ActivityAggregationStatus USING CONSISTENCY ONE SET active = \'1\' WHERE aggregateKey IN (?)', [aggregateKeys], callback);
};

var setLastActivityKey = module.exports.setLastActivityKey = function(aggregateKeys, activityKey, callback) {
    Cassandra.runQuery('UPDATE ActivityAggregationStatus USING CONSISTENCY ONE SET lastActivityKey = ? WHERE aggregateKey IN (?)', [activityKey, aggregateKeys], callback);
};

var iterateAllAggregates = module.exports.iterateAllAggregates = function(batchSize, processBatch, callback, start) {
    if (start) {
        var cql = 'SELECT * FROM ActivityAggregationStatus USING CONSISTENCY ONE WHERE aggregateKey > ? LIMIT ' + batchSize;
        var params = [start];
    } else {
        var cql = 'SELECT * FROM ActivityAggregationStatus WITH CONSISTENCY ONE LIMIT ' + batchSize;
        var params = [];
    }

    Cassandra.runQuery(cql, params, function(err, rows) {
        if (err) {
            return callback(err);
        } else if (rows.length === 0) {
            // No rows, we've finished processing
            return callback();
        }

        // Get a hash of the row so the consumer doesn't have to work with cassandra rows
        var aggregates = [];
        rows.forEach(function(row) {
            aggregates.push(Cassandra.rowToHash(row));
        });

        // Pass the results to the consumer for processing
        nextBatch(aggregates, function(err, stop) {
            if (err) {
                // The consumer has flagged an error, stop processing
                return callback(err);
            } else if (stop) {
                // The consumer has told us to "break", stop processing
                return callback();
            }

            // Continue to the next set
            return iterateAllAggregates(batchSize, nextBatch, callback, rows[rows.length - 1].key);
        });
    });
};

var getAggregatedEntities = module.exports.getAggregatedEntities = function(aggregateKeys, callback) {
    var params = [];
    aggregateKeys.forEach(function(aggregateKey) {
        params.push(aggregateKey + '#actor');
        params.push(aggregateKey + '#object');
        params.push(aggregateKey + '#target');
    });

    var aggregatedEntities = {};
    Cassandra.runQuery('SELECT * FROM ActivityAggregation USING CONSISTENCY ONE WHERE aggregateKey IN (?)', [params], function(err, rows) {
        if (err) {
            return callback(err);
        }

        rows.forEach(function(row) {
            aggregatedEntities[row.key] = _rowToEntities(row);
        });

        return callback(null, aggregatedEntities);
    });
};

/**
 * Convert a Cassandra row into an array of activities extracted from its columns.
 *
 * @param   {Row}       row         The Cassandra row from which to extract the activities
 * @return  {Object}                The activities that were extracted from the rows
 */
var _rowToActivities = function(row) {
    var activities = [];
    row.forEach(function(name, value) {
        try {
            activities.push(JSON.parse(value));
        } catch (err) {
            log().warn({'err': err, 'value': value}, 'Error parsing activity value.');
        }
    });
    return activities;
};

var _rowToEntities = function(row) {
    var entities = [];
    row.forEach(function(name, value) {
        try {
            entities.push(JSON.parse(value));
        } catch (err) {
            log().warn({'err': err, 'value': value}, 'ERror parsing entity value.');
        }
    });
    return entities;
}

