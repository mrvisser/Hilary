/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var shortid = require('shortid');
var util = require('util');

var AuthzTestUtil = require('oae-authz/lib/test/util');
var ContentTestUtil = require('oae-content/lib/test/util');
var LibraryAPI = require('oae-library');
var LibraryTestUtil = require('oae-library/lib/test/util');
var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests/lib/util');

var CollectionsConstants = require('../constants').CollectionsConstants;
var CollectionsDAO = require('../internal/dao');

/**
 * Generate a number of collections for use in testing
 *
 * @param  {RestContext}    restContext             The REST context to use for making requests
 * @param  {Number}         numCollections          How many collections to generate
 * @param  {Function}       callback                Standard callback function
 * @param  {Collection}     callback.collection...  All collections that were generated as separate callback parameters
 * @throws {AssertionError}                         Thrown if an error occurred generating the collections
 */
var generateTestCollections = module.exports.generateTestCollections = function(restContext, numCollections, callback, _collections) {
    _collections = _collections || [];
    if (numCollections === 0) {
        return callback.apply(this, _collections);
    }

    RestAPI.Collections.createCollection(restContext, util.format('displayName-%s', shortid.generate()), null, null, null, null, function(err, createdCollection) {
        assert.ok(!err);
        _collections.push(createdCollection);
        return generateTestCollections(restContext, numCollections - 1, callback, _collections);
    });
};

/**
 * Generate a number of collections with the provided visibility for use in testing
 *
 * @param  {RestContext}    restContext             The REST context to use for making requests
 * @param  {Number}         numCollections          How many collections to generate
 * @param  {String}         visibility              The visibility to apply to each collection. One of the options enumerated by `Authz.visibility`
 * @param  {Function}       callback                Standard callback function
 * @param  {Collection}     callback.collection...  All collections that were generated as separate callback parameters
 * @throws {AssertionError}                         Thrown if an error occurred generating the collections
 */
var generateTestCollectionsWithVisibility = module.exports.generateTestCollectionsWithVisibility = function(restContext, numCollections, visibility, callback, _collections) {
    _collections = _collections || [];
    if (numCollections === 0) {
        return callback.apply(this, _collections);
    }

    RestAPI.Collections.createCollection(restContext, util.format('displayName-%s', shortid.generate()), null, visibility, null, null, function(err, createdCollection) {
        assert.ok(!err);
        _collections.push(createdCollection);
        return generateTestCollectionsWithVisibility(restContext, numCollections - 1, visibility, callback, _collections);
    });
};

/**
 * Set up 2 public tenants and 2 private tenants, each with a public, loggedin, private set of
 * users, groups, content and collections. The resulting model looks like this:
 *
 * ```
 *  {
 *      "publicTenant": {
 *          "tenant": <Tenant>,
 *          "anonymousRestContext": <RestContext>,
 *          "adminRestContext": <RestContext>,
 *          "publicGroup": <Group>,
 *          "loggedinGroup": <Group>,
 *          "privateGroup": <Group>,
 *          "publicContent": <Content>,
 *          "loggedinContent": <Content>,
 *          "privateContent": <Content>,
 *          "publicUser": {
 *              "user": <User>,
 *              "restContext": <RestContext>
 *          },
 *          "loggedinUser": { ... }
 *          "privateUser": { ... }
 *      },
 *      "publicTenant1": { ... },
 *      "privateTenant": { ... },
 *      "privateTenant1": { ... }
 *  }
 * ```
 *
 * @param  {Function}   Invoked when all the entities are set up
 * @throws {Error}      An assertion error is thrown if something does not get created properly
 */
var setupMultiTenantPrivacyEntities = module.exports.setupMultiTenantPrivacyEntities = function(callback) {
    // Base the collections privacy setup on content. We then create collections to go along with them
    ContentTestUtil.setupMultiTenantPrivacyEntities(function(publicTenant, publicTenant1, privateTenant, privateTenant1) {
        // Create the collections
        _setupTenant(publicTenant, function() {
            _setupTenant(publicTenant1, function() {
                _setupTenant(privateTenant, function() {
                    _setupTenant(privateTenant1, function() {
                        return callback(publicTenant, publicTenant1, privateTenant, privateTenant1);
                    });
                });
            });
        });
    });
};

/**
 * Add a set of content items to a collection, ensuring that all items have been added succesfully
 *
 * @param  {RestContext}    restContext     The REST context to use when adding the content items to the collection
 * @param  {String}         collectionId    The id of the collection to which to add the content items
 * @param  {String[]}       contentIds      The ids of the content items to add
 * @param  {Function}       callback        Invoked when the content items have been successfully added
 * @throws {AssertionError}                 Thrown if the content items are not successfully added
 */
var assertAddContentItemsToCollectionSucceeds = module.exports.assertAddContentItemsToCollectionSucceeds = function(restContext, collectionId, contentIds, callback) {
    // First ensure the collection's content library is not stale
    getAllCollectionContentItems(restContext, collectionId, null, function() {

        // Add the content items to the collection
        RestAPI.Collections.addContentItemsToCollection(restContext, collectionId, contentIds, function(err) {
            assert.ok(!err);

            // Ensure that the items we just added to the collection are in fact there
            getAllCollectionContentItems(restContext, collectionId, null, function(contentItems, responses) {
                _.each(contentIds, function(contentId) {
                    assert.ok(_.findWhere(contentItems, {'id': contentId}));
                });

                // Purge the collection's content library so we can rebuild it from scratch
                _purgeCollectionContentLibrary(collectionId, function() {

                    // Ensure once again that all content items are in the collection
                    getAllCollectionContentItems(restContext, collectionId, null, function(contentItems, responses) {
                        _.each(contentIds, function(contentId) {
                            assert.ok(_.findWhere(contentItems, {'id': contentId}));
                        });

                        return callback();
                    });
                });
            });
        });
    });
};

/**
 * Try to add a set of content items to a collection, and ensure it fails in a specified way
 *
 * @param  {RestContext}    restContext     The REST context to use when adding the content items to the collection
 * @param  {String}         collectionId    The id of the collection to which to try and add the content items
 * @param  {String[]}       contentIds      The content ids to try and add to the collection
 * @param  {Number}         httpCode        The expected failure HTTP code of the request
 * @param  {Function}       callback        Invoked when the request is complete
 * @throws {AssertionError}                 Thrown if the request did not fail in the expected manner
 */
var assertAddContentItemsToCollectionFails = module.exports.assertAddContentItemsToCollectionFails = function(restContext, collectionId, contentIds, httpCode, callback) {
    RestAPI.Collections.addContentItemsToCollection(restContext, collectionId, contentIds, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Add a content item to all the provided collections, ensuring that all items have been added successfully
 *
 * @param  {RestContext}    restContext     The REST context to use when adding the content item to the collections
 * @param  {String[]}       collectionIds   The ids of the collections to which to add the content item
 * @param  {String}         contentId       The id of the content item to add to the collections
 * @param  {Function}       callback        Invoked when the content item has been successfully added to all the collections
 * @throws {AssertionError}                 Thrown if the content item is not successfully added to all the collections
 */
var assertAddContentItemToCollectionsSucceeds = module.exports.assertAddContentItemToCollectionsSucceeds = function(restContext, collectionIds, contentId, callback) {
    if (_.isEmpty(collectionIds)) {
        return callback();
    }

    // Add the content item to the next collection in the list
    collectionIds = collectionIds.slice();
    var collectionId = collectionIds.shift();
    assertAddContentItemsToCollectionSucceeds(restContext, collectionId, [contentId], function() {

        // Recursively add the content item to the next collection
        return assertAddContentItemToCollectionsSucceeds(restContext, collectionIds, contentId, callback);
    });
};

/**
 * Try to create a collection, ensuring it fails in a specified way
 *
 * @param  {RestContext}    restContext     The REST context to use when creating the collection
 * @param  {String}         displayName     The display name of the collection
 * @param  {String}         description     The description of the collection
 * @param  {String}         visibility      The visibility of the collection
 * @param  {String[]}       managers        The manager principal ids for the collection
 * @param  {String[]}       viewers         The viewer principal ids for the collection
 * @param  {Number}         httpCode        The expected failure HTTP code of the request
 * @param  {Function}       callback        Invoked when the request is complete
 * @throws {AssertionError}                 Thrown if the request did not fail in the expected manner
 */
var assertCreateCollectionFails = module.exports.assertCreateCollectionFails = function(restContext, displayName, description, visibility, managers, viewers, httpCode, callback) {
    RestAPI.Collections.createCollection(restContext, displayName, description, visibility, managers, viewers, function(err, createdCollection) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!createdCollection);
        return callback();
    });
};

/**
 * Create a collection, ensuring that it is successfully created with the provided properties
 *
 * @param  {RestContext}    restContext             The REST context to use when creating the collection
 * @param  {String}         displayName             The display name of the collection
 * @param  {String}         description             The description of the collection
 * @param  {String}         visibility              The visibility of the collection
 * @param  {Object[]}       managers                The manager principal infos for the collection
 * @param  {Object[]}       viewers                 The viewer principal infos for the collection
 * @param  {Function}       callback                Invoked when the request is complete
 * @param  {Collection}     callback.collection     The created collection
 * @throws {AssertionError}                         Thrown if the collection was not successfully created
 */
var assertCreateCollectionSucceeds = module.exports.assertCreateCollectionSucceeds = function(restContext, displayName, description, visibility, managerInfos, viewerInfos, callback) {
    var managerIds = [];
    var viewerIds = [];
    var allMemberInfos = [];

    // Generalize the potential user and group info objects so that they have a `profile` key
    // instead of `user` or `group`, then collect the parameters needed to create a collection
    _.chain(managerInfos)
        .map(_generalizePrincipalInfoModel)
        .each(function(managerInfo) {
            if (_.isObject(managerInfo)) {
                managerIds.push(managerInfo.profile.id);
                allMemberInfos.push(managerInfo);
            } else {
                managerIds.push(managerInfo);
            }
        });

    _.chain(viewerInfos)
        .map(_generalizePrincipalInfoModel)
        .each(function(viewerInfo) {
            if (_.isObject(viewerInfo)) {
                viewerIds.push(viewerInfo.profile.id);
                allMemberInfos.push(viewerInfo);
            } else {
                viewerIds.push(viewerInfo);
            }
        });

    // Get all the collections libraries to ensure that the library index is populated for all users
    _getAllCollectionsInLibraries(allMemberInfos, function(principalCollectionsLibrariesBeforeCreate) {

        // Create the collection
        RestAPI.Collections.createCollection(restContext, displayName, description, visibility, managerIds, viewerIds, function(err, createdCollection) {
            assert.ok(!err);
            assert.ok(createdCollection);
            assert.ok(createdCollection.id);
            assert.ok(createdCollection.groupId);
            assert.ok(createdCollection.createdBy);
            assert.equal(createdCollection.displayName, displayName);
            assert.equal(createdCollection.description, description);
            assert.equal(createdCollection.visibility, visibility);
            assert.ok(_.isNumber(createdCollection.created));
            assert.strictEqual(createdCollection.created, createdCollection.lastModified);
            assert.strictEqual(createdCollection.profilePath.indexOf('/collection/'), 0);
            assert.notEqual(createdCollection.profilePath.indexOf(createdCollection.id.split(':').pop()), -1);
            assert.equal(createdCollection.resourceType, 'collection');

            // Determine what the full membership should be, including the current user who created
            // the collection
            RestAPI.User.getMe(restContext, function(err, me) {
                assert.ok(!err);

                // Add the current user member info to ensure the collection gets added to their
                // library
                allMemberInfos.push({
                    'restContext': restContext,
                    'profile': me
                });

                var expectedMemberRoles = _.extend(
                    AuthzTestUtil.createRoleChange(viewerIds, 'viewer'),
                    AuthzTestUtil.createRoleChange(managerIds, 'manager'),
                    AuthzTestUtil.createRoleChange([me.id], 'manager')
                );

                // Ensure that the membership is what we expect
                assertFullCollectionMembersEquals(restContext, createdCollection.id, expectedMemberRoles, function() {

                    // Get the collections libraries after it was created and ensure that the collection is in the libraries
                    _getAllCollectionsInLibraries(allMemberInfos, function(principalCollectionsLibrariesAfterCreate) {
                        _.each(allMemberInfos, function(memberInfo) {
                            assert.ok(_.chain(principalCollectionsLibrariesAfterCreate[memberInfo.profile.id]).pluck('id').contains(createdCollection.id).value());
                        });

                        // Purge the member collection libraries and check again to ensure they update properly both on-the-fly and when built from scratch
                        _purgeCollectionsLibraries(_.union(managerIds, viewerIds), function() {
                            _getAllCollectionsInLibraries(allMemberInfos, function(principalCollectionsLibrariesAfterCreate) {
                                _.each(allMemberInfos, function(memberInfo) {
                                    assert.ok(_.chain(principalCollectionsLibrariesAfterCreate[memberInfo.profile.id]).pluck('id').contains(createdCollection.id).value());
                                });

                                return callback(createdCollection);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Get a collection, ensuring that it fails in a specified way
 *
 * @param  {RestContext}    restContext     The REST context to use when getting the collection
 * @param  {String}         collectionId    The id of the collection to get
 * @param  {Number}         httpCode        The expected failure HTTP code of the request
 * @param  {Function}       callback        Invoked when the request is complete
 * @throws {AssertionError}                 Thrown if the request did not fail in the expected manner
 */
var assertGetCollectionFails = module.exports.assertGetCollectionFails = function(restContext, collectionId, httpCode, callback) {
    RestAPI.Collections.getCollection(restContext, collectionId, function(err, collection) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!collection);
        return callback();
    });
};

/**
 * Get a collection, ensuring that the request is successful
 *
 * @param  {RestContext}    restContext     The REST context to use when getting the collection
 * @param  {String}         collectionId    The id of the collection to get
 * @param  {Function}       callback        Invoked when the request is complete
 * @throws {AssertionError}                 Thrown if the request did not succeed
 */
var assertGetCollectionSucceeds = module.exports.assertGetCollectionSucceeds = function(restContext, collectionId, callback) {
    RestAPI.Collections.getCollection(restContext, collectionId, function(err, collection) {
        assert.ok(!err);
        assert.ok(collection);
        assert.strictEqual(collection.id, collectionId);
        return callback(collection);
    });
};

/**
 * Get the content library of a collection, ensuring that it fails in the specified manner
 *
 * @param  {RestContext}    restContext     The REST context to use when getting the content library
 * @param  {String}         collectionId    The id of the collection whose content library to get
 * @param  {String}         start           The starting point from where to list collections in the library
 * @param  {Number}         limit           The maximum number of content items to fetch
 * @param  {Number}         httpCode        The expected failure HTTP code of the request
 * @param  {Function}       callback        Invoked when the request is complete
 * @throws {AssertionError}                 Thrown if the request did not fail in the expected manner
 */
var assertGetCollectionContentLibraryFails = module.exports.assertGetCollectionContentLibraryFails = function(restContext, collectionId, start, limit, httpCode, callback) {
    RestAPI.Collections.getCollectionContentLibrary(restContext, collectionId, start, limit, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!result);
        return callback();
    });
};

/**
 * Get the content library of a collection, ensuring that it succeeds
 *
 * @param  {RestContext}    restContext         The REST context to use when getting the content library
 * @param  {String}         collectionId        The id of the collection whose content library to get
 * @param  {String}         start               The starting point from where to list collections in the library
 * @param  {Number}         limit               The maximum number of content items to fetch
 * @param  {Function}       callback            Invoked when the request is complete
 * @param  {Object}         callback.result     The result object, as per `RestAPI.Collections.getCollectionContentLibrary`
 * @throws {AssertionError}                     Thrown if the request did not succeed
 */
var assertGetCollectionContentLibrarySucceeds = module.exports.assertGetCollectionContentLibrarySucceeds = function(restContext, collectionId, start, limit, callback) {
    RestAPI.Collections.getCollectionContentLibrary(restContext, collectionId, start, limit, function(err, result) {
        assert.ok(!err);
        assert.ok(_.isArray(result.results));
        assert.ok(_.isString(result.nextToken) || _.isNull(result.nextToken));

        // If a valid limit was specified (valid meaning above 0 and less than the maximum amount of
        // 25), ensure the `nextToken` is shown if there were less than the expected amount of
        // results
        if (_.isNumber(limit) && limit > 0 && result.results.length < limit && limit <= 25) {
            assert.strictEqual(result.nextToken, null);
        }

        // Ensure each result has an id
        _.each(result.results, function(result) {
            assert.ok(result.id);
        });

        return callback(result);
    });
};

/**
 * Try and get the members of a collection, ensuring that the request fails
 *
 * @param  {RestContext}    restContext     The REST context to use when getting the collection members
 * @param  {String}         collectionId    The id of the collection whose members to get
 * @param  {String}         start           The starting point from where to list members of the collection
 * @param  {Number}         limit           The maximum number of members to fetch
 * @param  {Number}         httpCode        The expected failure HTTP code of the request
 * @param  {Function}       callback        Invoked when the request is complete
 * @throws {AssertionError}                 Thrown if the request did not fail in the expected manner
 */
var assertGetCollectionMembersFails = module.exports.assertGetCollectionMembersFails = function(restContext, collectionId, start, limit, httpCode, callback) {
    RestAPI.Collections.getCollectionMembers(restContext, collectionId, start, limit, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!result);
        return callback();
    });
};

/**
 * Get the members of a collection, ensuring that the request succeeds
 *
 * @param  {RestContext}    restContext         The REST context to use when getting the collection members
 * @param  {String}         collectionId        The id of the collection whose members to get
 * @param  {String}         start               The starting point from where to list members of the collection
 * @param  {Number}         limit               The maximum number of members to fetch
 * @param  {Function}       callback            Invoked when the request is complete
 * @param  {Object}         callback.result     The result object, as per `RestAPI.Collections.getCollectionMembers`
 * @throws {AssertionError}                     Thrown if the request did not succeed
 */
var assertGetCollectionMembersSucceeds = module.exports.assertGetCollectionMembersSucceeds = function(restContext, collectionId, start, limit, callback) {
    RestAPI.Collections.getCollectionMembers(restContext, collectionId, start, limit, function(err, result) {
        assert.ok(!err);
        assert.ok(result);
        assert.ok(_.isArray(result.results));
        assert.ok(_.isString(result.nextToken) || _.isNull(result.nextToken));

        // If we specified a valid limit and the result set was smaller, we must have no items left
        if (_.isNumber(limit) && limit > 0 && result.results.length < limit) {
            assert.strictEqual(result.nextToken, null);
        }

        // Ensure each result has a profile and a valid role
        _.each(result.results, function(result) {
            assert.ok(result);
            assert.ok(result.profile);
            assert.ok(result.profile.id);
            assert.ok(_.contains(['manager', 'viewer'], result.role));
        });

        return callback(result);
    });
};

/**
 * Get the collections library of a specified user or group, ensuring that the request succeeds
 *
 * @param  {RestContext}    restContext         The REST context to use when getting the collections library
 * @param  {String}         principalId         The id of the user or group whose collections library to get
 * @param  {String}         start               The starting point from where to list collections in the library
 * @param  {Number}         limit               The maximum number of collections to fetch
 * @param  {Function}       callback            Invoked when the request is complete
 * @param  {Object}         callback.result     The result object, as per `RestAPI.Collections.getCollectionsLibrary`
 * @throws {AssertionError}                     Thrown if the request did not succeed
 */
var assertGetCollectionsLibrarySucceeds = module.exports.assertGetCollectionsLibrarySucceeds = function(restContext, principalId, start, limit, callback) {
    RestAPI.Collections.getCollectionsLibrary(restContext, principalId, start, limit, function(err, result) {
        assert.ok(!err);
        assert.ok(result);
        assert.ok(_.isArray(result.results));
        assert.ok(_.isString(result.nextToken) || _.isNull(result.nextToken));

        // If a valid limit was specified (valid meaning above 0 and below the maximum amount of
        // 25), ensure the `nextToken` is shown if there were less than the expected amount of
        // results
        if (_.isNumber(limit) && limit > 0 && result.results.length < limit && limit <= 25) {
            assert.strictEqual(result.nextToken, null);
        }

        // Ensure each result has an id
        _.each(result.results, function(result) {
            assert.ok(result);
            assert.ok(result.id);
        });

        return callback(result);
    });
};

/**
 * Try to get the collections library of a specified user or group, ensuring that the request fails
 * in the specified manner
 *
 * @param  {RestContext}    restContext         The REST context to use when getting the collections library
 * @param  {String}         principalId         The id of the user or group whose collections library to get
 * @param  {String}         start               The starting point from where to list collections in the library
 * @param  {Number}         limit               The maximum number of collections to fetch
 * @param  {Number}         httpCode            The expected failure HTTP code of the request
 * @param  {Function}       callback            Invoked when the request is complete
 * @param  {Object}         callback.result     The result object, as per `RestAPI.Collections.getCollectionsLibrary`
 * @throws {AssertionError}                     Thrown if the request did not fail in the expected manner
 */
var assertGetCollectionsLibraryFails = module.exports.assertGetCollectionsLibraryFails = function(restContext, principalId, start, limit, httpCode, callback) {
    RestAPI.Collections.getCollectionsLibrary(restContext, principalId, start, limit, function(err, result) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!result);
        return callback();
    });
};

/**
 * Share a collection with a set of users and groups, ensuring that the request succeeds. The list
 * of viewers provided is a mixed array of strings (target principal ids) or objects:
 *
 *  * String:   If the viewer is a plain string, it should be a simple id of the target principal to
 *              share with. When a string is used, no assertions will be done on the library of the
 *              target principal after the share has completed, as we do not know how to reliably
 *              access the libraries
 *
 *  * Object:   If the viewer is an object, it is assumed to represent either a user or a group,
 *              containing both the profile and rest context with which we can access the
 *              principal's private libraries (e.g., the user themself, or the manager of the
 *              group). Given an object, the assertion will also verify that the library of the
 *              target principal was updated as expected
 *
 * @param  {RestContext}    restContext     The REST context to use when sharing the collection
 * @param  {String}         collectionId    The id of the collection to share
 * @param  {Object[]}       viewers         A mixed array of strings and objects. See summary for more info
 * @param  {Function}       callback        Invoked when the request is complete
 * @throws {AssertionError}                 Thrown if the request did not succeed
 */
var assertShareCollectionSucceeds = module.exports.assertShareCollectionSucceeds = function(restContext, collectionId, viewers, callback) {
    var viewersSplit = _.partition(viewers, function(viewer) {
        return (_.isString(viewer));
    });

    // Get the viewer infos from the input while making the object more agnostic to the principal
    // type by changing the "user" / "group" key to just "profile"
    var viewerInfos = _.chain(viewersSplit)
        .last()
        .map(_generalizePrincipalInfoModel)
        .value();
    var viewerInfoIds = _.chain(viewerInfos)
        .pluck('profile')
        .pluck('id')
        .value();

    // Get all the viewer ids, including those extracted from the viewer info objects
    var viewerIds = _.chain(viewersSplit)
        .first()
        .union(viewerInfoIds)
        .value();

    // First get all the collection members so we can ensure the library is fresh and compare the
    // membership before and after the operation
    getAllCollectionMembers(restContext, collectionId, null, function(membersBeforeShare) {
        membersBeforeShare = AuthzTestUtil.getMemberRolesFromResults(membersBeforeShare);

        // Determine what the membership should look like after the share operation
        var expectedMembersAfterShare = _.extend({}, membersBeforeShare);
        _.each(viewerIds, function(viewerId) {
            expectedMembersAfterShare[viewerId] = expectedMembersAfterShare[viewerId] || 'viewer';
        });

        // Get the collections libraries of all principals before adding them as members to ensure
        // they have been built and will be updated on the fly
        _getAllCollectionsInLibraries(viewerInfos, function(principalCollectionsLibrariesBeforeShare) {

            // Share the collection with all the principals and wait for the library updates to complete
            RestAPI.Collections.shareCollection(restContext, collectionId, viewerIds, function(err) {
                assert.ok(!err);
                LibraryAPI.Index.whenUpdatesComplete(function() {

                    // Ensure the members of the collection were updated as we would expect
                    getAllCollectionMembers(restContext, collectionId, null, function(membersAfterShare) {
                        AuthzTestUtil.assertMembershipEquals(expectedMembersAfterShare, null, AuthzTestUtil.getMemberRolesFromResults(membersAfterShare));

                        // Ensure the collection libraries of all the principals we shared with contain the collection
                        _getAllCollectionsInLibraries(viewerInfos, function(principalCollectionsLibrariesAfterShare) {
                            _.each(principalCollectionsLibrariesAfterShare, function(collectionsLibrary, principalId) {
                                assert.ok(_.chain(collectionsLibrary).pluck('id').contains(collectionsLibrary, collectionId));
                            });

                            // Purge the collection libraries of all users to ensure a rebuild will
                            // still contain the shared collection
                            _purgeCollectionsLibraries(viewerInfoIds, function() {

                                // Ensure the rebuilt libraries of all the principals we shared with contain the collection
                                _getAllCollectionsInLibraries(viewerInfos, function(principalCollectionsLibrariesAfterShare) {
                                    _.each(principalCollectionsLibrariesAfterShare, function(collectionsLibrary, principalId) {
                                        assert.ok(_.chain(collectionsLibrary).pluck('id').contains(collectionsLibrary, collectionId));
                                    });

                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Try to share a collection with a set of users and groups, ensuring that the request fails in the
 * specified manner
 *
 * @param  {RestContext}    restContext     The REST context to use when sharing the collection
 * @param  {String}         collectionId    The id of the collection to share
 * @param  {String[]}       viewerIds       The ids of the users and groups with which to share
 * @param  {Number}         httpCode        The expected failure HTTP code of the request
 * @param  {Function}       callback        Invoked when the request is complete
 * @throws {AssertionError}                 Thrown if the request did not fail in the expected manner
 */
var assertShareCollectionFails = module.exports.assertShareCollectionFails = function(restContext, collectionId, viewerIds, httpCode, callback) {
    RestAPI.Collections.shareCollection(restContext, collectionId, viewerIds, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Try to update the members of a collection, ensuring that the request fails in the specified
 * manner
 *
 * @param  {RestContext}    restContext     The REST context to use when updating the collection members
 * @param  {String}         collectionId    The id of the collection whose members to udpate
 * @param  {Object}         memberUpdates   The member update object, keyed by principal id whose value is a role to apply to a principal, or `false` if the principal should be removed
 * @param  {Number}         httpCode        The expected failure HTTP code of the request
 * @param  {Function}       callback        Invoked when the request is complete
 * @throws {AssertionError}                 Thrown if the request did not fail in the expected manner
 */
var assertUpdateCollectionMembersFails = module.exports.assertUpdateCollectionMembersFails = function(restContext, collectionId, memberUpdates, httpCode, callback) {
    RestAPI.Collections.updateCollectionMembers(restContext, collectionId, memberUpdates, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Update the members of a collection, ensuring that the request succeeds. The provided member
 * update info is keyed by the principal id whose role should change, and the value should be one
 * of the following:
 *
 *  * String:   A string indicates that it is simply the role to give to the user. In this case, the
 *              principal's library cannot be verified after the operation as we do not have a rest
 *              context to use to request their library
 *
 *  * Boolean:  Only `false` is valid, indicates that the user membership should be removed
 *
 *  * Object:   If an object, it should be the standard principal info object containing the
 *              `restContext` key (A REST context that can be used to have "manager"
 *              access to the user or group's feeds) and either a `user` or `group` key, containing
 *              the profile of the principal, dependent on if it is a user or a group, respectively.
 *              Additionally, there should be a `role` key that is either a String or Boolean,
 *              indicating how to change the principal's membership on the collection. If provided,
 *              further assertions will be performed on the libraries of the target principals using
 *              the provided REST context
 *
 * @param  {RestContext}    restContext         The REST context to use when updating the collection members
 * @param  {String}         collectionId        The id of the collection whose members to udpate
 * @param  {Object}         memberUpdateInfos   The member update object. See summary for more information
 * @param  {Function}       callback            Invoked when the request is complete
 * @throws {AssertionError}                     Thrown if the request did not succeed
 */
var assertUpdateCollectionMembersSucceeds = module.exports.assertUpdateCollectionMembersSucceeds = function(restContext, collectionId, memberUpdateInfos, callback) {
    // Determine the roles to actually apply, and those that are the memberInfo objects so we can
    // perform additional assertions on them
    var roleChange = {};
    var memberInfos = [];
    _.each(memberUpdateInfos, function(memberUpdateInfo, principalId) {
        memberUpdateInfo = _generalizePrincipalInfoModel(memberUpdateInfo);
        if (_.isObject(memberUpdateInfo)) {
            // Normalize the member info object to have a generic `profile` key instead of a `user`
            // or `group` key
            memberInfos.push(memberUpdateInfo);
            roleChange[principalId] = memberUpdateInfo.role;
        } else {
            roleChange[principalId] = memberUpdateInfo;
        }
    });

    // Get the collection libraries to ensure they are not stale and will be updated on the fly
    _getAllCollectionsInLibraries(memberInfos, function(principalCollectionsLibrariesBeforeUpdate) {

        RestAPI.Collections.updateCollectionMembers(restContext, collectionId, roleChange, function(err) {
            assert.ok(!err);

            // Iterate the collection members and ensure all the members have the specified role, or are
            // removed depending on the specified role
            getAllCollectionMembers(restContext, collectionId, null, function(membersAfterUpdate) {
                _.each(roleChange, function(change, principalId) {
                    var result = _.chain(membersAfterUpdate)
                        .filter(function(memberAfterUpdate) {
                            return (memberAfterUpdate.profile.id === principalId);
                        })
                        .first()
                        .value();

                    // Ensure either that the member does not exist if they were removed, or that their
                    // role has become the specified role
                    if (change === false) {
                        assert.ok(!result);
                    } else {
                        assert.strictEqual(result.role, change);
                    }
                });

                // For all the members we had a rest context for, ensure their libraries are updated
                // appropriately to contain (or not contain) this collection
                _getAllCollectionsInLibraries(memberInfos, function(principalCollectionsLibrariesAfterUpdate) {
                    _.each(roleChange, function(change, memberId) {
                        var collectionsLibrary = principalCollectionsLibrariesAfterUpdate[memberId];
                        if (collectionsLibrary) {
                            var containsCollection = _.chain(collectionsLibrary).pluck('id').contains(collectionId).value();
                            if (change === false) {
                                assert.ok(!containsCollection);
                            } else {
                                assert.ok(containsCollection);
                            }
                        }
                    });

                    return callback();
                });
            });
        });
    });
};

/**
 * Ensure the collections library of the provided user or group strictly contains just the specified
 * collection ids, and optionally in the same order
 *
 * @param  {RestContext}    restContext             The REST context to use when getting the collections library
 * @param  {String}         principalId             The id of the user or group whose collections library to test
 * @param  {String[]}       expectedCollectionIds   The collection ids to ensure are present in the library
 * @param  {Boolean}        ensureOrder             When `true`, ensures that the order of items in the collection library matches the order of collection ids in `expectedCollectionIds`
 * @param  {Function}       callback                Invoked when the assertions are complete
 * @throws {AssertionError}                         Thrown if any assertions failed
 */
var assertFullCollectionsLibraryEquals = module.exports.assertFullCollectionsLibraryEquals = function(restContext, principalId, expectedCollectionIds, ensureOrder, callback) {
    getAllCollectionsInLibrary(restContext, principalId, null, function(collections) {
        var actualCollectionIds = _.pluck(collections, 'id');

        // If we aren't ensuring they are in the correct order, simply force-sort the arrays of ids
        if (!ensureOrder) {
            expectedCollectionIds.sort();
            actualCollectionIds.sort();
        }

        // Ensure the sets of collection ids are identical
        assert.deepEqual(actualCollectionIds, expectedCollectionIds);

        return callback();
    });
};

/**
 * Ensure the members of a specified collection is strictly equal to the provided set of expected
 * members and their roles
 *
 * @param  {RestContext}    restContext             The REST context to use when getting the collection members
 * @param  {String}         collectionId            The id of the collection whose members to test
 * @param  {Object}         expectedMemberRoles     An object keyed by principal id whose values are their expected role, indicating the expected members of the collection
 * @param  {Function}       callback                Invoked when the assertions are complete
 * @throws {AssertionError}                         Thrown if any assertions failed
 */
var assertFullCollectionMembersEquals = module.exports.assertFullCollectionMembersEquals = function(restContext, collectionId, expectedMemberRoles, callback) {
    // Remove any roles that contain a role of `false` as they would have been removed
    expectedMemberRoles = _.extend({}, expectedMemberRoles);
    _.each(expectedMemberRoles, function(role, userId) {
        if (role === false) {
            delete expectedMemberRoles[userId];
        }
    });

    // Get the full members set to compare against
    getAllCollectionMembers(restContext, collectionId, null, function(actualMembers) {
        var actualMemberRoles = {};
        _.each(actualMembers, function(member) {
            actualMemberRoles[member.profile.id] = member.role;
        });

        assert.deepEqual(actualMemberRoles, expectedMemberRoles);

        return callback();
    });
};

/**
 * Page through all the collections in a user or group's collection library and return all
 * collections that were fetched
 *
 * @param  {RestContext}    restContext             The REST context to use when getting the collections library
 * @param  {String}         principalId             The id of the user or group whose collections library to get
 * @param  {Object}         [opts]                  Optional arguments for getting the collections library
 * @param  {Number}         [opts.batchSize]        The size of the batch to use to fetch the collections in the library. Default: 25
 * @param  {Function}       callback                Invoked when the full collections library has been fetched
 * @param  {Collection[]}   callback.collections    A list of all collections in the library
 * @param  {Object[]}       callback.responses      All the raw web responses that were received for each page request
 */
var getAllCollectionsInLibrary = module.exports.getAllCollectionsInLibrary = function(restContext, principalId, opts, callback, _nextToken, _collections, _responses) {
    opts = opts || {};
    opts.batchSize = opts.batchSize || 25;
    _collections = _collections || [];
    _responses = _responses || [];
    if (_nextToken === null) {
        return callback(_collections, _responses);
    }

    assertGetCollectionsLibrarySucceeds(restContext, principalId, _nextToken, opts.batchSize, function(result) {
        _responses.push(result);
        return getAllCollectionsInLibrary(restContext, principalId, opts, callback, result.nextToken, _.union(_collections, result.results), _responses);
    });
};

/**
 * Page through all the content items in a collection's content library and return all content items
 * that were fetched
 *
 * @param  {RestContext}    restContext             The REST context to use when getting the content library
 * @param  {String}         collectionId            The id of the collection whose content library to get
 * @param  {Object}         [opts]                  Optional arguments for getting the content library
 * @param  {Number}         [opts.batchSize]        The size of the batch to use to fetch the content in the library. Default: 25
 * @param  {Function}       callback                Invoked when the full content library has been fetched
 * @param  {Collection[]}   callback.contentItems   A list of all content items in the library
 * @param  {Object[]}       callback.responses      All the raw web responses that were received for each page request
 */
var getAllCollectionContentItems = module.exports.getAllCollectionContentItems = function(restContext, collectionId, opts, callback, _nextToken, _contentItems, _responses) {
    opts = opts || {};
    opts.batchSize = opts.batchSize || 25;
    _contentItems = _contentItems || [];
    _responses = _responses || [];
    if (_nextToken === null) {
        return callback(_contentItems, _responses);
    }

    assertGetCollectionContentLibrarySucceeds(restContext, collectionId, _nextToken, opts.batchSize, function(result) {
        _responses.push(result);
        return getAllCollectionContentItems(restContext, collectionId, opts, callback, result.nextToken, _.union(_contentItems, result.results), _responses);
    });
};

/**
 * Page through all the members of a collection and return all users and groups that were fetched
 *
 * @param  {RestContext}    restContext             The REST context to use when getting the collection members
 * @param  {String}         collectionId            The id of the collection whose members to get
 * @param  {Object}         [opts]                  Optional arguments for getting the collection members
 * @param  {Number}         [opts.batchSize]        The size of the batch to use to fetch the members of the collection. Default: 25
 * @param  {Function}       callback                Invoked when the full collection members list has been fetched
 * @param  {Collection[]}   callback.contentItems   A list of all users and groups who are members of the collection
 * @param  {Object[]}       callback.responses      All the raw web responses that were received for each page request
 */
var getAllCollectionMembers = module.exports.getAllCollectionMembers = function(restContext, collectionId, opts, callback, _nextToken, _members, _responses) {
    opts = opts || {};
    opts.batchSize = opts.batchSize || 25;
    _members = _members || [];
    _responses = _responses || [];
    if (_nextToken === null) {
        return callback(_members, _responses);
    }

    assertGetCollectionMembersSucceeds(restContext, collectionId, _nextToken, opts.batchSize, function(result) {
        _responses.push(result);
        return getAllCollectionMembers(restContext, collectionId, opts, callback, result.nextToken, _.union(_members, result.results), _responses);
    });
};

/**
 * Set up a provided tenant to have a public, loggedin and private collection
 *
 * @param  {Tenant}     tenant      The tenant to set up
 * @param  {Function}   callback    Invoked when the tenant is set up
 * @api private
 */
var _setupTenant = function(tenant, callback) {
    _createMultiPrivacyCollections(tenant.adminRestContext, function(publicCollection, loggedinCollection, privateCollection) {
        tenant.publicCollection = publicCollection;
        tenant.loggedinCollection = loggedinCollection;
        tenant.privateCollection = privateCollection;
        return callback();
    });
};

/**
 * Create a public, loggedin and private collection using the given REST context
 *
 * @param  {RestContext}    restContext     The REST context to use to create the collections
 * @param  {Function}       callback        Invoked when the collections are created
 * @api private
 */
var _createMultiPrivacyCollections = function(restContext, callback) {
    _createCollectionWithVisibility(restContext, 'public', function(publicCollection) {
        _createCollectionWithVisibility(restContext, 'loggedin', function(loggedinCollection) {
            _createCollectionWithVisibility(restContext, 'private', function(privateCollection) {
                return callback(publicCollection, loggedinCollection, privateCollection);
            });
        });
    });
};

/**
 * Create a collection with the provided visibility
 *
 * @param  {RestContext}    restContext     The REST context to use to create the collection
 * @param  {String}         visibility      The visibility that should be applied to the collection
 * @param  {Function}       callback        Invoked when the collection is created
 * @api private
 */
var _createCollectionWithVisibility = function(restContext, visibility, callback) {
    var randomId = util.format('%s-%s', visibility, shortid.generate());
    var randomDisplayName = util.format('displayName-%s', randomId);
    var randomDescription = util.format('description-%s', randomId);
    RestAPI.Collections.createCollection(restContext, randomDisplayName, randomDescription, visibility, null, null, function(err, collection) {
        assert.ok(!err);
        return callback(collection);
    });
};

/**
 * Get all the collections in all the libraries using the provided principal infos
 *
 * @param  {Object[]}   principalInfos                          An array of principal infos, containing the rest context of the user whose collection library to get
 * @param  {Function}   callback                                Invoked when the collections libraries have been collected
 * @param  {Object}     callback.principalCollectionLibraries   An object keyed by principal id, whose value is the array of all collections in that principal's collections library
 * @throws {AssertionError}                                     Thrown if there is an error getting all the collection libraries
 * @api private
 */
var _getAllCollectionsInLibraries = function(principalInfos, callback, _principalIdCollections) {
    _principalIdCollections = _principalIdCollections || {};
    if (_.isEmpty(principalInfos)) {
        return callback(_principalIdCollections);
    }

    // Copy the input array so we don't destroy it during recursion
    principalInfos = principalInfos.slice();

    // Get the next principal and gather their collections
    var principalInfo = principalInfos.pop();
    getAllCollectionsInLibrary(principalInfo.restContext, principalInfo.profile.id, null, function(collections) {
        // Add the collections to the array and recursively continue to the next
        _principalIdCollections[principalInfo.profile.id] = collections;
        return _getAllCollectionsInLibraries(principalInfos, callback, _principalIdCollections);
    });
};

/**
 * Purge the collections libraries for the provided principals. @see LibraryTestUtil.assertPurgeFreshLibraries
 * for more information
 *
 * @param  {String[]}   principalIds    The ids of the principals whose collections libraries to purge
 * @param  {Function}   callback        Invoked when all the libraries have been purged
 * @throws {AssertionError}             Thrown if there is an error purging the libraries
 * @api private
 */
var _purgeCollectionsLibraries = function(principalIds, callback) {
    LibraryTestUtil.assertPurgeFreshLibraries(CollectionsConstants.library.COLLECTIONS_LIBRARY_INDEX_NAME, principalIds, callback);
};

/**
 * Purge the collection content library for the specified collection. @see LibraryTestUtil.assertPurgeFreshLibraries
 * for more information
 *
 * @param  {String}     collectionGroupId   The authz group id of the collection whose content library to purge
 * @param  {Function}   callback            Invoked when all the library has been purged
 * @throws {AssertionError}                 Thrown if there is an error purging the library
 * @api private
 */
var _purgeCollectionContentLibrary = function(collectionId, callback) {
    CollectionsDAO.getCollectionsByIds([collectionId], function(err, collections) {
        assert.ok(!err);
        return LibraryTestUtil.assertPurgeFreshLibraries(CollectionsConstants.library.CONTENT_LIBRARY_INDEX_NAME, [_.first(collections).groupId], callback);
    });
};

/**
 * Convert the standard principal info object model into something more generic to work with. This
 * basically entails converting the `user` or `group` key which points to the user or group profile
 * (depending on the type of principal) to the key name `profile`
 *
 * TODO: We should change the result of both `generateTestGroups` and `generateTestUsers` to return
 * this generic model always, rather than a `user` and `group` key which is difficult to work with.
 * This has been deferred from the collections PR as the impact on the code base would be too big
 *
 * @param  {Object}     principalInfo   The principal info object to convert
 * @return {Object}                     A principal info object with a generic `profile` key instead of `user` or `group` key
 * @api private
 */
var _generalizePrincipalInfoModel = function(principalInfo) {
    if (!_.isObject(principalInfo)) {
        return principalInfo;
    }

    principalInfo = _.clone(principalInfo);

    if (principalInfo.user) {
        principalInfo.profile = principalInfo.user;
        delete principalInfo.user;
    } else if (principalInfo.group) {
        principalInfo.profile = principalInfo.group;
        delete principalInfo.group;
    }

    return principalInfo;
};
